<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc49e1a7bad9e1f69357cbc17c1e3fc1f13ff6370713584589cd2d39456810e48ecd18f6a6192d6597f82fa629e7a9aeff8283ee27727d506dd35e0b7e126201ec70e5dd5a05dd887c267b4607c626d040fa6734729138ba721e1c273d257f7aa4dcdbbd5a763b652fb281986c863b95c436b914d7a52a6cfb16e239e740e782bb4fa3ea9d38715ab543ff6577c86442b7941fa7445f7a2c9a34f77eff9171308d0b79d79d5d3aefb8724fd4a603a86ffbb263229c73a9b188bbba584f5ea34b4d6cc764bfe7fc1e08545afa0316001c7ee82fec593c1bcb036aa40b30d1d4a6f33138d8ea8840d8f13fabcb322a143b9de34fc3daba31cf2e4018b88d06c0e83ca64aca925974dd7e3052e3cd7c506e2ea94448e99befb383fae04e494688da38e6d042c0aa37402ff044b9a5140056f1cd30ef0b607c9fa9857c8697ce95deefdbc9c8673569ad9c05f0e2fecc64f62581a19e60ad5e1513ca09836c64554b87978a97e25ec7baaa0c90843e8379438162f7d954c6ae4909467573ad06d354e2d963b0f9b76fee159deed1d61947941b59121c51d4242148f2142200714f91eca249ce2d5179cae58186d75c0a805312a24bd8c1fcd04c276d80562f7031b46965c3eb2a0e4350331dcd26ee4f633117a976eab79d53a1bd6b7799927f3011fd87d260e8211010205f39b211a112bcb7f662f9cd6fcfa193b1e76666de8f403aaa8d3b319e6e349dda3802cbbfaf6ef076f26b8a5df028aa22311d1a5a2c6322e2d6a8e3c65de692029f0fa3230a32201122233b3ec88ea43f75bfb0990d8fee8cbd9851d8f2ec5c0bc780d575152c89bfff6e1beb78c537405873bd90bd6326732d6fac35284a1a9fc2434e3065a7dc7c74d3a642e670196a1274979de3ca87d25f4c2a58318429977fffcfa8bd87ae144820c3692f76a9c2e32a1d6853581e63a6cc1f3d3d5a66994a3429b77e72065108e7d556793effbf809931e100df8cef69b772f9840f41581863b944187c732893994f2184c5d6bb58ae4c52672e5b52a1a2c7b372790d868c193b72b71e91e7713792153966e1e4a14a5df2d1a4db53e09353c2e03bfdaa01ec3fd021f082f21bb20c806957626ac5eace25caff2007ed81bf50cc04647d17279742f74c57fe11514e87d997ac16ed99581ce001944e6b6d5db170ba05aea51e1d4b676c78ebd1e33bd69a99a8b47bee21dfef3ae76976039d2ced836c66ff22843b797cd4d17a87cd1fe518755eb8666aaebca70f0d80318051376ebc8c464e8f5b4a154fc563384e694bd184e2f3ebbe5815b4430dd7fba051c7452d79ac027e8c6a7afabf90854748f4e46126409e7010ab9de8ca96f054b322f2a351bb74c87db262913c765df3df950685b1995b1c013dc7db21ef800da995b99552ee48c1f72e3c23efe57b1c212c0637167228c10cdec5c1dd776c0a2c95cdf705a9a99c2b7a2336a35124f15fb87c3a558535ab0236f21ca2e77c7bd873ecbc06e9389b145c730c74ad529ff5b10ddb6b206c5ce369e10ec813808a86e60dd7b266718e9584f3208a27deea6ffe8f1ff87abc50d8ad58644253cb5ee3ffa0ad47064db6fb683a1e381417cf21075f9e14e99c9e45693161c91da549ca2bf8bf97a5d7d83db0bb302a87b6141d2c41d41fcfd94251e1eb3e34d8b338b4cba031a23a6e7114ff795a17dc0aae4e99b3005fff84a02795f79d0d933cfe13afcbfa2ce03bdaf9678b099432dda098be109980deaf60db0490e0903da1098e1469aa804ce84d54ef3f45aa88b3f0b0c09bc3d9d78bb7f0399ca3cf62c5371d5d3be6f7715db73d9ff9bf2dd086b431382ae5fcad2f9e6892787da58e6d23fcc8cad7e6a0fafb13bc693622333adc34e49cf946ac55f2f10c529bb30a62e2059ce25df283bd6384b121e3b5d346e093dd5baabc64cb80d76a87b4363a7a270541fe4427247b82e31a9823ed1138e7c9d11a37a32cf664068b658bcac0fe3584fa5e3feca738d20f43f7c9beac4c02dd09045e40c4bc96e72995d5e4f2f840a19861b4a045bc848b5549034500c2b3e5b4b5ea7e562302c6c3feaaff8558c0e4466543b8cda3aa58a1b244d34b17d1da65bb37a879f611cf4ede92076f5116368de47591aefba7406e3454cfa6a5785afa12170d5416f752f13520acee10189d81d7fb739716212c49db0bc6273bb6b695b46911ee9c76b2e552d54ad951dbc509fdded3a10523561b2cbbab41440f01706105d0bdcb0575084464a2d0ee3d5c03ef7c4dfb639881fa7c11073c2ab6fbcc6371595a60aa2d51446b7df43a36138a42cb4fb46d09b4f2b4066b8caec05d08be3d2a7ad49bc9c0f0f4c0946b22160737b7f0db9bb090d17b5e55bb1bff9c5b3bf6923d7f84dabd6c71cb05a23c421d85dc398c95cd17d43b40a4c5ae7d074097b47ce18b67d511b82febff3d8040378236a5602b41c011931f1fb3603e1dc5c33196ddcf945f129a192af489041145090b70adb3238d159382c0ad405797d7bd575264c4e63f2fa6ca30806dc8033531c528fbcff985d72d5f7c7d78992ac12143bf607d6999ff002633e21ee78df2db05974c50cfbe567e88c17927b3fd6b6e450eee830c27e4023301122bfeff4e09c0bda9d9c79b3de10b6ff5912c77a685cbfc472c5a6287f9576c31efa2f1b35481d5f39656e8efe24ff91dc7dcc2ce6304ff79ea0fdc3f05bb3ce3839a86ea8724f0c69ec04ae546dd8e3c948990329967bcb32f7484fb73cfd323e18cfd6c326d1acf7451343aebf02da9304b737e7767b620110a0cd321c4b09890ee45db621761a416ad4a6adb00e341bc000f44d7396798f22c3badbb8cdb46eb3b4e43c7cda752ce9c59e869ed703b96cbbeb5c1c4b35353938d0492fab4a0d3774d184743441144da4be426b05d09748d84a15bb64ee3a02907d06d87dd5315c357ccee31b972cd78be5d1e3e0dd6fade475e1b2ac51b31d9729792cc3b60343bb7529e184d78efbf401ecb2454ceb8cb1e48909181f3579a3961693e5d7d391e58e8d492ffffe75bfc8982511af4f4e0832d146a973cbc97af19ea5c008e005ec918a13bd412320b30c4280e23654deff8a65b89c2686c036e12b0e063346339ec32d5d8c526864e5164206095ea70b365c4c6fb9ed0b19ef5060a095488d5f8bd01451eb982c59ff786ff792e012ec1175062eb8cd611a60db12d58e9035b83f40f7585396eb485355a08686cb15f7c110308f10079ef4ecd84da3ad0d7d405e547ff3675c9e1e7d279f1056e71659ea84f1150bda03266b3b04e0b5993198caa55bdb1d6b483f2f01741c77c56992a668b339f1d2cdb9399f163eb0cb6f6ed416c289b41f9adc3a921fd27733906f46ee1279f1ab60043a49b6c45735825beb0d596178faf6bd28f8f809f826a09d78902870ee20dbe57d48fb40c4b22724ca3db1c0c1bf5ceeb90b639ad374bd882d186d205fcfb44afe1c62f5f45be5bea6f0dd343f27bfdc388d28cbc4aa9ef9e69b4735d9c405c3acf242308b4a6035ee7217cdc2aeeaf83737501e360250ef631ae7f9772b606ea21dc3e1523a3f0ffd067106fb2fdf0c1a7fc552e4302ef215227fc5bd08f74e8f9a6874b325f1376ca4a4fb4fd54806c8e2ddc863cb90d5b378606c0f697933d23e1e059ec02bf5ff04c83f73ec1481e804a1308cef93c3d2711cd7d5743d30f862de27ffe340bb0cca861ee9864c75ed45d6f631e41d7e34cd108acc4977195471174ca505b4f30226c08ab2e9b19892a870222c2556c9dd2e662306d1650c7fe9c7bf7d9e42534090ded0cc7d17c3f1d6d72f7b728a7723241f72ff6135f5a653e309c98796dbf35d9547ea3da13c0631f73747312d60cb8f4982881b8288d3ba67d8b0fa2796ad85c1eb792037ca621e965c1a081962426b32810f424b6f1b485512255a6caa0e9555ce06f02448f809f227cd0d16da20e41f769b0161da9d3f031659dfe521f392abb1dca58ac6da00ea75f95d04d2ac201495f01182fdc6fa25de9c2572f9749a0bb9b54ac753e1006483de3692341ffef907961db8a2d4938b7acc307688fa778867106b1b734d41c022d42d66e5358409b924015e4ea4c7b3ef60458977219358958af1d65beb94649517c0cd62af4baa442f9011a2a5a74fb5a9d95e934ad04a3501adcae38c195b7facf33ab99b145d8f483fa133c86023d02625dab862e9efb3ba189be9545f380abdb6c195564a8a9c0538b24a97f0b0c9f0ead340a2c6766a63fd7033723656a45510642b3d21a086f8e605f70e9b6b8f6da05d1433808f506812b256fb2a17ee8074d6fa5d5e9afd0c2eda608b92c040af3c79032e480250f8eb954dd3ff9e956ae5e098cf67f3826f5e0568068b498bb92775c8e945280ab1dab9b8335b781b22a041004a11a66eff38fd507969971655a79ab1496469747b90bc34e64662fc3587476a67b5ad161b74e3784706b482b94061fcfb63201a9f08f3f7686520b9894cd65e8fe793ff4d3e1e9bf40d40d2e7336ae6f56acc4fc5328c9ac6bf036a25b1cc71bfc4080f21b5c5ff0aa188104322456fdaf3d7030d05d18f5bc577805825e3cc381dd9d59d7aba5d066922968f55718a08ae6d608ce32c0d35858c45406af769e9c232ff1ec2a14a0358583568ffbfc6fdf8d87c5d7426265321c7e7d9c9b43495253cccb39645eb5c443a0562ae8f968268147b4f1810583f1a8fe474afd77d21a5560523a21099f30c543acdbad88c5111a7f523809a8bf35a1e7106b0f4773b60a45746b19035b0d393a7fc445760f77c398979c44b66e91be1864a4e95c3b9d5f26b536182ab0ff9835fd3036ac3c17f2f92d69fe92eb8ca7a6a76795c738a6dddfaa31ad9abe623729c86f071f00a221c1b3996d9b985cba34c3677400ed0c63f67219beb43f40d4dec7ca6cef296fbe895fcbe2547f2b4c9b75331d6e8cf67c67305c57666df9763e82f5ed04d63551be0243cc527e17d4464b96242c36f4c578ff8fc1c7c876c99dbb5e5df0d0886c1d991837d8a4a774fa241801b47c2dae9f851b38d5ab57685dd0ef2a2cf040d9548af7e44f417c49a484a7ae4d38132fa2fa08fb929d8b0972c5a97d78df61aea0853d3ca7d2ca6db6d8036083c7cea0bbc3f2dae5a80ac8c3eb2360bac0687318149c719b0c646e1374852b74263603a39c64e0715fe5c3f3985f6858a1b9940da84097ccaf8b48b6c1951a6823f97dfce10a2999b289ea68a294ba3edff42c7089ea99147921be635e3adcb31f1d33f184d0252a2e0e978a1f4a527061973b137eb9f81dca53d8fadbd9b3eff117ede5ea6a518f42a81efb500775ebda93c311034dd134e745bb51428a8c40f8974d2ff1212b05346aed2c931f3907822343a0bd483689d71698d415498a622ad6ad652e619fd3e9cc59e3d50a956805c1f1504344adf1761c6cae995bf2c5486cdf2c341e644fbaa1d1e03d89e64f7e6b6aa6afb87f46b3608cc7d67ebb26bc2e2678166737f3a9c2b8819c05e090e5d317632024f98b9f4af3365735506ed948240c9e9c974f6cbd7e24cd1a5c6926e59513d00fcd5f505e2242c2e548ebbe3ec7a09aa20f3bf658730d276e733820e9895d9b114f47a232202728f2828f790a9cb4207da76286b34bd226ea143b2757bb62ab94d9f749846b52d75d56153d73d2147d84ba747a35ea8b1373f7c52b205e44d53e6c23fdf47c0301ed739d4a84cd7561bae73f856cc424087e38ec87ba58f633f6cb059b1c1058a4601c4db06c8a62099c5bf00834bf00e27d69e59d51744d0a387eab8091b5cea4ecbb4c02eaa5cf3ec5407b288a6de377427b6c107bd282c8aae969f27f23a66d7d66252ee8f5398b12258987ff81723999930d1e63f9568e9195057d6d1dc57a8bd2f2f03d38a3150bf5ae39d4846b6bd46fee73a8e21991d8325a9d81f7ac70d22e56418f2f78675aa51608be4441156015d530feedd518af2c291b755a64008baa426b111a4027352584cd746fbe30653a1241c0d798cd4943a7da43fe548944be8cddcf40a103cf5251753ecca568e765022d0afa97b3ff37d6643fab7fc82ca46f2ccb3bcf456c1043ca4e3107b55813aac5d3e1c7eb2311b678d437bd72dea77fe03e8cdfa73e081558797b83186046f52b79878291696f57bc1e91b65e60f4d6813b15937d96f52d8ba7019d5284221b3fc17043a5f7ed51e74263c7707bdc885db9ced49290d95370fa4d2c9ed2fc0ad3d4bd77f8d4985cbec8c8ba91e4683d3598bd62d5cc58d72e6bb92ac8c43c8c3c2c35c3f4ec17dfea777f2c0daa70953bb3f2ff6e08f4c6d0c3d8f48dfcdb42b5dc726e6561e4a7f1c34d9260d54c4e9055729dde8dac4f1fa3676bd6ba44aea499ab0b62e10ad3732791cfe076f5bbb0a187b2d25686a6a91d6f5b3b06b3a0bf1179914941540f3890fcd553c64cb24a8b066d074b8b3ab753bb978904be1c70ecee0941b747e87a0358337281d51755f57a82695285fe8f686b1b82c2ee14b9303ee4c31e915e45fc12a483098785e93c88d9f5215527219782a19a5151b47f5447ce18c104196b72bd2b976932a6d8d58b570730f824f0da4f8b3c1764a4f2485453dba7a7aef7be915f045a933ca6df53b7de10f857c9000dafeec09f7a58662428c89b3009b9ff688fb668acabfb5cd12de31ad0d977beefb006d72fc78e54e5eb6e7b3961cc727e29233ece52b2a9f16d93ba8f373c5e4b76dac51bedb2da35543e0bff3186772b9030e54625996b46c7cd6ae821c68e94ec82fe9ea59c3b81c19a65db910bccfed827846fd04e974d42e2b4db3c69c096b27f57ae35dc7a224f811400de2c18d624691d5ab08056b3d3f82f4a7fbb6017ac41578814d06399981cce0f06e6ba31fb5fdc9775d485adb0d0bd5575235df04a6c530367da67c9c18473aac15b215b8f19272a005bc8adf641fbded2a8b4873c247832db5e29f163d0580ea7889a6a433f5fe7a58e40d48e78fd2e20e286fb32838dc71ce0144576952e0da3e3525bb1ba44f0e904c8c56f9fc927bfc21fe6880810a7ce36901ea240cf2cfb4e8763eb8d038fa0e354cfec29eb4bfc95c2a2e193f975847d0924f75e2597ea28eb79891ed3f75e357c45c6c6ab563d266cb3e6e8df2093827322eaf2677d7dc4b8ed845fbd4f28b0be927d4ba1d05dc7d9353fce61bb4dbfaa726758c2ac85da066efdaf2bee2b281f0b6b4a9655ba37e7bf6a3b495996429c0d6a5d83b75b69d8975bf597086ca897de670fda5065d912bc956a69128c8017c10d5285068afcd77bba23917953c71a4bdd9e26a371ea2ec03db59dc4c0c57f785410afe37e2e1f6e7d98056875baa185738d3bd7f81355341ec91fb2cfdbbd361f81da0abc8428993296df5c02993441b12530ed85e9f0070fcebffc548aa103512cd729b46bde4e34b12ea689425b1f023275cf18ea6501691ab193c9844fea57f1b20a0682d048e89e0ef078ab9b1b0f1e689419840bbd852d58bb4f2dd15f8a2b7e4b703d5d696e8ee352f3e28549ee0b3aeca70343ca9fde775e9bceaf6043d1dd0f6b4afcae94f3af843a55e4c34d8ed5f81c988e14890a366f719889220f5365b436270babef5cc2ac35708b6ae0c6d959cb19ed0157335ea6f1548cb5443a86489668c4ce6bfdaf6b4ff82f8ef8d92a57806544f1604760c35a33cfbc0859ce3fd5b7ab5837d897dba823abc6e79b36dbf46aa30685af05aec14bc3a28cd141bf2decc2b7fec1a260c20f135744ea548d59daf6c008e710547b32f2aa855211b49bb9561ca6b72626db65a3892e8fb071f5ea31bbaffc3bc7db9587e3ca048ed7566b8c122debd57e70d3bd96f335be29b87a4c47dca69e04ff1babe353ddbbb5ae1ddcb065129578167729a804ed5382d4e50d736aebdf973aa820ad4f2ef06d15e275bb6f323c2d677edab4d08fd818c84ea59de88d8141bc9d843a644e20a36ff50af4d6f47f185836d8129a19e56ce03f98bdb5c438cd203d13dc6cdaedc51d05d89a10d5fc303c033870f7ff1ab8bac2354a685a5f78624c34ea14f93f3dfad993539f996c4d882c58934f9a5990bdc251f407aca540591e162a2e255ce3447fabb7fc8a42b228bea9b6b3396797a1efc439de60dc06ec8117ab13590c14dc9a6c32e2242d45a878ff9d905c9cdf2e9ca02f59881bc1d2326ce7f828b06e495ce15231fd7e3ca1df4b775bdea5cadb42bc523402c5cf215f0b486d7a5ee625bbc0c6a2c62006a444828f20305193b39540daa3e75148622c378d9f39615b326bfd371307df41adbd11b1951e170229f51435d34e7e146dc73f0be9244f9105a3277d1cfa55cfe0ab8eca84f4fab8b3abbe6cd6930cdff49ebfe21839cb725657b18fa2b56985937988764f1d2baa66118f8a7510c898ddb366c0c08a4c8fea50424aa432e7dab540ecb1d6f2086df5fa8a521403dfd326ce8707909ff0269edfa04b1437cc3a1e1a0e10ac674410f87b4fd4af88e9dcb015c88a6c5b16ae081bcb4fce6ffaa4d1dbbb7797815db02635c65c3a7a3e5378467463c583dee7846cab8bc964581f005fe7ef8e45f6310630204d0ca213ad7fbb487985b05520edc6cbf2089ebc7ea1b12c157395c17e5b9c5b8c41d9841fa0f751dd0140d5820bbf41b0c889096cd1759f17e155f9576b00626f37da5959224415da696c11301b19505f62712c67c62ba7d3ca91182cb743536023ba653d9f094544ee219bd3792fd1c35c0e17283aa153914ba4386417a9b85ba6f98261f2df4b9430f02028f364f38a13aa3c3be46a5a65039c1c7bf0b37338bf2d985e201fc373e872bfd7c7fbde30d2e443e3e2db78f855d1701dacbbf2b0da5ca4a658736924fd770521522a4e71fd9886f28d40af8212ed2e33c547c259a09afb4d42cadc783ae255d498ac033162c054cf7b8a9476e3082fcab14640e1181d2a50dd9bbaf19bdcdbb445bccc8bf984b4a3d143ec891ed74b622b00dde473bf4f23bbb00db2d2e6ec1a7f9f97499f3c8ec7b7dd9447e706d652c3f6c294aa796c67c3641105a1d8794cd2f9084a5d1ead978e44428b223c0482111465194118e9c9f19adef90ff7296edea1c67443f323c0afc8f40186667598a3c81b00f35017c545a7ab58df68737c237d3b411dc405124aa8df59f84e84bc9ba7866ea79ca0368694facd22c038666c329a3821fafb300bef9b8d37fabd8ca2fbeb88eee9c31724455538fb973fb8b9380ce4aa016c211b6230b15419712348e0448930d802556cc603367b808d90a5fa9e8de67794b7ea6f15bbd9af333b713aa321eee669516fd3284b4c5234ca463c13cad552ce86d269c8889e6cfe2472abc55bd479359724a80cf176f48770142191eafc3a79ef35446fb385ac1f5193f94354d86a70b4036f7c45a7727478fcfbd7bdd90917a980ab56cb0b31c8eeedce135db4753f1585833d7d6845cee5b8e7bdac8f02c0bd16b93bf701773282206ffb9c1970718526b087093b774d7f5aabae1c5a14d76b61a0aa1f7666ff11be0975af76cbaee345b40b9328dd9095d6bb3f09d09ac1a55384c093ca2fb9169b2f9fe9bcf7b598cddc27b5463d73d35b84734a66d3b98fe38a0e9d4d2c3802040e94c1bface29f0e0ff233f61280b0d414365289daa3c87367f861e3e182ba22066831db0a217881b9773353ab5c24f7d8cb3e51cd16eee57ee28f32eea1fc203b28716147746db4e4fbf2ddfbc05ebf3f4ff2b9c3da1554228a3e20952b2af689137bff02ab72428f9020ea6254310e1e1dc7a5c566c8830b12c81ec2c036c1f8f5c965af38995754489f8568f3aae6325bd9ed8d80d7e727aee69031355d9e2df51589325a3bde849525bdfec8ab474a021e5161b8e0ca6d3abc849f294dfe7d46547a947e996108e03e3040eefe343aab15bce8ce4a5fa61e14466317b38f3f864d13f44466c6c2bd6e156e8aeba3336fd577ebbe8275cd2dd5c81b0e0e380bb57b3506669c79ff3511c3e89e914d365f6f0f5592525beb6a5a3085e9bf4b62c2b9e992cc0996575259cf09b0249195c562d24a4ddc20212022c40da882eb9f4d2d02db60a7f5bdebcce0e3ef02f7c00debc71306633e67eb649498a3759eb17376519e437697eb1a86a712c22284b90d1209d90ade4b685fd3145490d72e9ac62c5db6ce9f0c99afab2bb759e01616d7a6f40be965436ec73065da07fe0a3cd0dab6a775bec9ac020f3abb6c17356d411ef74f39afc686cb8dc3f4523fe39f3e826e38ddeb58f45c39a9fd156ad36a1ff9230a069614f1788e280d7ce741abb7df5f151ebf526e3e0fae6ad1d64b8246dac821bd8cdb9aff325bc6420c49943112877758ac401e1073e6648864196ba66ddd7c22ed924d28d2182a539de93952c08e63e796fae53827c0764a30ab818023f94ac04b4403830ac5e0a6e4f4157a780783945e62ae67bafbbca53e86cbf52260b1b2a6d5a8910b168cba87a3736d70a92849fa60d7511d3ae134056b38a92e733327ba85b3d0cf337720c8273b087344ac0898b71f9210e273d86fc523ed694175d7743c9accbaa0e4021e1ba2f9ac5dcaa8c6276b48c4042b1b0d20611610e317437353a20f8e3951c27fb6a5eb1d10b4675b4f2281db9f641b936a5dbc19d967085bd80f4d165da43d9b250e5f12b6d37a1f2ccf724f78b5bf4284c059b19a639338abfc285ff5dfe66818284c4fe0b95f4596d3dc386b150e5168a74318e2434f38973a4035b384beb0a3f25b2ed0ab23b0e3b9b840722ea4b55b216c1616199b04b976f896d15468889210062896d5420c9487b9f2757a34988cfab419c4db5c9a74cb864e513c90292799a7dc7e073e954f754a336c0cf21d4b62868cd4a41eaa6194b821a5508cdac1bfb78964414309e38bf7b74eb5843baae7eaaf9545e56673dd0741a47cfd5067be49523f1e47b399b8446e993a1a08895e277e5dc872513ca17725a93de6675c5b89d60ed4006b8c975832e3971e3056bec117c9f9f2310f7b9769beace1887e6e0454f3c78697aca3811d45daf04b3960b84b10a310192844546dfd6502c0bdd66ecb1f8b915f7169a70aff96d92355147165d57c1f8c9018c6b635c3a1cdcf28ea32763e1aa84d87d9f1eae695a23ae6ca3b11878b9287e7293a9b192c2e7f398feccfabffe2509f5cd1599c1fc133920bfe94a59376fa80ca647dbb2025b85f165de2acba80f0f7c521531ab738c418155d2a51ad1222c98a6e9f4437b6bc6d86ead4d6b4163f8496dabc0c744c71bb657a32e7a6d806d76684c3f963f5d928c21290178f2e646a3d9e7f5af70379e60c4c77deb3752d80d377d39ce93cae05f12b2ef877efb3cdb4156590f47dfff62b1d4d82a70889eed6b995c47fbe95b8cf4ec2764745ed80d026f6f3da6f81a49760fa9c0464e5d88cff8000aa3aa5aa3277980f58e215ace0797ff06ecba90441fce09e6008f8a50e203c64c2a864ff0f9cb3842b0d6d0a8dd968cf883fe42f65ab6db3a01f12bcca5ba310ee30d6bd95fb08948d73b4ec9d03a5593b9bbbc8bc8ccea491b17b1f7157d79be7c3fed03d1ccd0d3be56a214932dbb55e79fa63cb9ac68de22f8e58137efdbb4e698e6a1894ee652db3247692ad22e3b930ef15ae84dd395a03dd2b65b3aad88359fa172508eba036dd1810210b728d0b9cd53f9f2be1f93e5df8a207a656069f188ec2c96ccdf4ea23596babecabe1f03555976f6d4e321fa5e35e2716c46872e727f5c6f997847799e2cb8460d097bfe26d17ba86c2bd32de3cea0a48947d74bdabf96b93567108e7224d346fe8ac9f6dbde66267dbe657a9e26e674128c3685f2d107eee172a6aef7e14c09abcd53bc32ee98aa52471aea56772ba2ba385a4c29fde1618a1bb9258d0275487e3f62c7223addda05396a623664b114d0fd7bfd1cea3e5217f63e51f8b2b8074f924863ad86273ca3d140e7c71fd95ca2a800f83f4a0ebfac9cfba9cc475da415f2205364e6f43c285a722382caf98898c36966db299349b29506bcce92d20543a4f97fccf6a987df0125df1b5eea59294a833d06960ef95cfddd169d8591a31d2d01320485f8e005e157a3e19a36e4a5cbb2671b54c78cfb77c56bb65da9c3dad957b8c0a235fddab1dfad683b5a4dea68acb43ca1f7e0c39d85177afd57b67212e47940f785341a493f5975fe42a99ecbac9fece7f46f555583f28416b31ad8b29dd28dd83533e305be715b5cea6d101f705c3a782cead461b6e7aa971812aba6d24dbf2851c40d686f9ca8b66293699f4f51210dfc5ee19d3f07385453e8d573260b245a7a94722d4cb790feecb10075edc578b1a9909551afa33a5121880528d0f9f21571a4764876853cbc66fa3beb63914bf6be4fb68ad88f0c19b8f58ed1b9c6165097a8b1aec191373968225fdc1c1c91aa03182c617b2845b9ea8570d8c1bd50842c0b6f7448710e2c2667a9cdf0ad32ee81e84c8df40fbbcd5ea47773f79c05d1458eaac828710a1bd119a69bcdf706621ade74d3bd6c54b6fac1e28a50ebbc8e568f9319511c7da43d875807c959db4a2ccd189cdaae896752b0f899c1cfd81822a5731eae6d995c1cdcd2d4333ee3fd7348d5fe2f3e7eb36ab31509f7602ded28c4f3d30c47f54c6a8175340f18c7ea9eb064c336e9286c02abb861984e66ddae469fe8358cb8b05a738ba0c29a774188c02b530f6df93a22391d4bab8884abaa35e40e5021b6db16b6e9586b11a8bba55fc53c23f56088795bded7ad22349a388483e34c5f141370d919f731503963908006f6494e2940ea3edc4e4bbdd3e889e096c5397311d91061d56883596154e691f24e1bdaab7617f03e28faac291b18f049e4236865838b7c21777e8a3928e062d4ebb4cf1a47dc7cd1c7b181c46c0b3f61d3d4d87f37ffb69287951b2180a92082d25c76d1b04fdced1b821bd61b52a3d809271afbff72f11c35c43c4e05879ebe45e9dec760357227a6a3240f93baccdfc98467103a4e121620b60afd4c79291bc50bc24da9064be286723059099be6c61eb7eaaeb1453eb0155adf2ebb4ba0f03d8ad1ac89ec002063ac13197770bfa363c74a2f3ba767fa37bd06d7676100d75fc31e5465c6ea01f5afcbf85b86cb319044e54c22fbc33660176dea120c434d3299ec9ddf9b3ae69819eadea0b31e7eb952bc10e68bb2068406d5bce064f499974b2d2e4d72078f51f824c4445eceefe9bf8f1512512a0a532d1c3efc79e14b49a0437fb2e5a155de85940f2d1b3d2155b0a7add048d418902fe7d4e6362593312fa617ebb7282d423bc20770fcb2f050afa01ed5a5f9043da20e9aa32797512cea4da334e012ac624c22ea2ddcab770ec340bcee5eabd41b17c15dc01373af0b4af0b90f79df8d58c8482d97e70ba0904f0368b361fb1ea964c7e51e3c9ae3a30171ff4dfd9edd96e6710c18c0378443a58203e56dd599cf1533698aef66e66b8b78103d241305373e4358c6444ba3085793414a1450a7907873c84d171d0b6d9cadf55541990578324395130d1eaa3e324ea33548b5642392701bd9bd2490397a1b6d78fcd4a654cba9c3bd9342e143380c61e9f2beaea21cbf3cc82ac7c72f86935e68c1541de5f45a577e53b26cc00949d624529d6031013b2624e8bf8eb50f3c2a4d36159f72f9428a337adf0e9c47d37e2f038357c0c1a12f3114d1133","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"7d0ca636c5b63cbb8ae09731b99d1d5f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
