<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89e44c3284fbe6ee16faa9fc3d98d06ed6f134b9cdf1b3843850d25449f3c6428d946fc84e240e13082ba0fe4ff1bf3c8f48f350b9e210714d46f66c14cac34c87d2f41c12456da2ac0e5974c582ce6303d920993d35e9624ca5b669024eff78c93e90ddfba61c10999fa29f34fdd92cfef61db71f349f6d3a3281182b48c1f6f91f41c898a6d6f073c394f9db017eee63f704ac73039fed389817121a2b5d6a6cc441004a645313772a360590219bcef29f3f44f8a3fff4d85aa108d34727943622da63eef59bbbc5b260e46cc0ca29c19695cb94a8d5c3b22e58134e930fd8b03d3cb243b466232ce84733533846058feb271f3f38da445ccc3c28c5e4411d0d0e3ae7961c9de3628bda947b35430be5ac594a102a39e5b99d1012a972f491a8cb0760e120436c3fb98a0c03bc8300558add1a39c4f46713b8936660d25fefdea2c88aa3880dcc9490ee0223152c308c42e296b5bb56cf8e1f70736d54bc3345906062f729ecbeceddc2b1d9cc12b4ffdcc49c1ae949205b976c8863ed23d10b71caf878cfb0617920b936ab5bb15570f7f4d183edec1b80e84000178e87ef0c549a71d50b1bbe975f821559ff84555050063d1e3d35e1eae27d9968532a688d5a348cd28163518135bc28669c9847120761526103c3b8b1b7f4eebf876525572b6128d85ecfa32dccc972f2833254c32bd69d0ef3dd10e4eadf5dd921ec3de314cca965b7f42e7bb9a7b520be7da8080b28d9163669f9a6cae21c5af1cf27171dd78d245862c9232d47100d2378c15d08cd2dd7b7f5b81595d836f8d5260acfd65f708a35f44c6c3d9f2f32c40de447e337918da6c9048337133fe26ac28d8d66765bb18a05d00a7239ff9678631294c7d00f877ce66eda226e4d9ad18b693d02ee960ab0e9b951145765bb78a4de3b06e870019953cf3dcf8c23ad25263b1d44612356dd8aac49217cb2c6391c30b41a481ca7e385773b37d4622577ff492498dde425e8298c0f6cbb805467e1851bd62f3aa79ef0f773cd9a70319271dd02c3f4b6cdde967f3b9ba1221f01925783d8e40aee02ab8a5d487673ac5d785ef36d38b1e69e0115e3f0ba79f36cce06b6e82c7e57d1b2755aa8e801b36c566af3f7ee9c692e3ba9fa84f6723e1962ad0b8cee6ff8f7e49f84f6c135a7ae19412960edf50419040c765babaebff3989257f03c0be85e4aba5a9548551fc7d763af8d3dcd322432c5bc62953bf53359edc686770050d7d047b18eb54b9ddfd8887b39c31804dbda7916f82ebc9189edba119961cea1454c1eae744598676e09ba7447fdf0c49c6fbf4d18888dc4635db0ed68c906a55053fdc73c394f6dfc6a5c5d68ac357d5aa87ba896482e894d75d485254ae5c56b00d436d3e16eb51078e4f144b567b0f3cf7b581522a7f6f3418880e22c2d56abe475d0f4f3ec84dece0e02eabca1595a2222b0a7312f77576296ac30af0ee753fd158f989069edd5f623b5fa72e0b4a85ac5d061448177aee154436a102712cfa4136733d41ddcba15229b18560ce27fb1f898916bcb07ff302beeaea9ce16e4b1e3acceaf1cdc38c497e6d68efbbdcd3a49b33e1992124fc8d246bde0dd905c5229755b900901194aec98e321119f2c74886c59a430b308a451ce53cff38bad60ff12b6028a773a74d96102058522f338229f1f75c02aa78be9f69f20390758790cafe9c9433c6a089f28692948727b4d6125b59f184d17a3ba11d0b74528ca7b3b38ec9849bb2b89fae248641fb62635389c02327716ab4865d95e9b4101e815209d35de4f8aaab6b12a8117ebbacd28fb41e64e8a06cc7e0c519c3cdefdb99a949dbf1198df89c70e9b0977e0ce95b279d1c3b3270d82f6db97f2f85509e85d82a00951e7fcd29e9c07d354f30a4651bcfd2d0a196952a524efb915211dd446ac1aa727d94c8ce105e3fda3c352c89fefb936d3a8b5ec74fdb2655bf1b2bc0539e5b6392e88dea1cc19922c9a1bc9afe139fbd80189c41c821e984e984df0b884f9e77599a5815f270af2a7bb806a66b9514799debd879139740a9c2216b9c5b16a861fa6b03f818fe5dde2c535cde6ce5b1bea38b59a39e9118b203976be2a4ff70f03ed6789db5f01b4c331bf34c63fd967affd78f4096f587b6ad7837ca646529affb3611134dd3db522ad1679f5c27c4a935f86ff2835a1bf5e7e52bfca90916ba2270641a1bd061e2169f6eeb2d80a2489bb9fd9fc16a1975d1a56719cf55cecc89a7885c56bec161616af2c61515d69f775f056d35869c438c96bbefb400f6165a1fcc2a26a44dde81a813085b44e264391b37c5bbd49bfd6ac183a923a5111adc77e589189ecd77ed2fa5fc7488a37c70bba3b456323acba472ea6d52a8f805ddf9f36d510933e92600acba0d3ffbe41e402df1dc73f265b39c226afd9aa925711852a06effbbe684b600011be048e5d39deffe5314c2cbe414cacbec43483e9f5dbbff039cadf5638e31acbdd1f9ed9137f9966ce5b2d4bafe7784cd7d33289841b6cd299a5bac34620d2e0ef602888c72cb3993a30f54dce6951ea9824ca65399ce35be7f4e5331dbf8c5e8cea2bcc0c033cf782596d766c5a9fc8e2d82f1955b28dea77404959fb5e8cc04e25d89c9b0526febc2aaed99580eea26779e155321a27243ecefbf83b9a7ef200fac71ba3e0728bad285c00953dac79a83c3ccce76e569cbcb04c14b6374d1a14d3d106f7a5c5f09c0888f0c22c76737f77a22abb73990c1e7283ac1e58ae4aaf6b7d2d06a35cf23190fe64679b7ef912e56483dcd1479197954116ddd5fb6cce1ccd6d2c854db5c0743b553bc9702879ff1035a118b6809ac59c1958643d1f725df9f975c6d8e5d67bbf472ba18e671b3d847037d0fcbed9a0d252ea6a0772df8905747249acd69aba6ce7482b427ddcfc5625dc367bb7159f3b51039223d1edc68d96ac25f6e0358056c7711ad159dfee74de660365730517f2cd31e1d65105b2ce3967d81d1c95c18ab431a9179bd16b29d412822f33aa08f935a11bd53fdcb67b7829c6d991d26e0bc3056b0dc9d1c3b15275f13d2a238bf238aec0e3bb44d3d20d9e4233ee1d0048b640bb4c9399473185f3c6765f3a365b3ad1eb20e130fab843d7ae07ae4bbb9175939ab52b671141ff3ce2f248755247c25943f855c28abeb995f9dd8446b89e5b2c41f8e9a65afa4392d1470e06cbf9d22e54434685a01768acde8649e2b1be208bcdb5cddba32eae5cb21eb558ae32260714fe7639d26efd2c3f8b3a6d772fb6b78f22e3fb4c344e1aeb968bed52f2868922cd3427fb87f57ecab1a093c8c7234db8a0643c81ec3a327745c86fecdedb030c175aa4b1712c1941a8ac2e43ff4fb57798badff6c520cc22820e274370b659c4485f81beb5619f1311cd980f3315c1a5615ede5a56e57181f1a34da87565b744d4095b8553c583378e5f1083b05eeb76d800624771fd7c9aa0f543a6133d66915d80e8aec052499318031f10d8f36c8d989f2f8542a463f7ab0d35684a8c09a4b6463f440dbbee327391261f8ffccf3e99fe264df9aaa0acd3295ecb5239da3cc0c4c7001558481896d100b4834f540beeb3f6d0ade49a5e486581886d34cb26f6ef7362aa590c2ad4a2cb9ce0367898638c6f035be0d87b3d36edb6bc6f1837bc4c10c3cf91f18c42d3ab4dd494efb74e97e97047e871cc0cc299ec49644b5f717a3ba0e705b68331fbcffe5aa29710af6d11022a661ceea3117475dd796849ee373daba4ce59c2c5b86dad31eede970be1f74d686dd72a2c0ee5bc3cd16e259ac458092ce7a75ebf69a94e052a99d03d23120a8179c23ef3a42a1262067ae8af3852d370dfea0d3d4bbf7e36f8b912f3ff6aa5769e72de244fff47d695fb232e08bd7e7db83183e6a50273f789bbb7ed0c1b59258d4c1e9f2698ec5d0d6cf1a51102d559b5d7dbd4903fdd486e5373c33a17247eb2db5df6ddc21c43a788e7181bcd9b8f8aa408989ac8a54d8a41bd36e5086710fe3df44d353e67dbec8d35d08670222814b12a7117bbe43f86ae66574cf975d22c21c51b4d8a7bb62a23479137e1a8b268625f283aedd27f99538798423bd7eb8b3fa8d32736628020ddf6b2982cb5b50205eac2196c3cafedc4b3f84c9869482385d2fb23c53ed9590dbca584e2fe66bb3db2c57bc5913837a178b4971150dbfb0ef1db53400b8f9c1281e3fc31b895799d736f2efcaafc038f5e10a568dc80dc83c8117cf082d56544e388f2579e1420f699582ac7b31c679e63f4c898afd4f19304d4104d91ff0ea5a6b1a005db2ccf7552b8f756afa7675229e3d31d1e9d1ccf4b192a80137d632158b7185f35afaf76670d49a77ca43912c65cab1dea8554e1cadd0a211dd91941e8933c67a5d837db157f1e84f46eb4d192dfe7999351bed0053152d89721689d70439a7e257869a47a94b9f90d9f6151346aeaf012bfd6d483df3b2365fadfe2be080e8076b1e41a376d7931525da2e9132564f8b1957f351dbca0fc8806296869baf0d285b79f367da45efa152d26f15fbbc11f350ea5f99c3f05671dce12d6d5eb7fa85a6973f2d5c5b207742348947062e999599b7abbcc0c5227e9765eb7aa37d10db864f8e2b6e3ea4bf20702a01030374f03e6d60a8587850838a53a651d6bba7d25deca4a2f62d5f0190eae8a20764382f7b3931c68bf09965f500d87d60c1d567372c50a5b4ede2defc78bb2fb4ac542cde6b2bcd5cfabfd4d43a9d9691d3421c3be7f7cea51012fc296af2005261ec51ed3148db82b7f2a3918c756e02f00ccc3aea8d08bf1693739133d7ce62c8a2f28538452ab8bce33d0c0b3283ad23d3686aa69134f67ce5d11232d01d8f6b683bc60ae4fb519c210abd9d1177b68b4522d161af027d4aa9a1fb5a2ce5e553ca734bc74277bb2269604eb74a672802aa714c84634a8d984cd9a45bde71959fc051af6e8a148e3b2212710867ad7036b513411e309887323f3ad67cd8e8fc8616654e887b5a62eae91d624bb3f46817922179912511af76db7f1ae78b1f5e69fc25d5b06381634e85ebd740f236736940daa33858e840fdd90eb6d2382d2c49babf7f3427f40917a29184adde5a7cd13381b530779f3d33ca9a716398a3c4dba365d3ab062ecd36cd06cc5b815ce94422962d07d620bd2e52ce83a07c490c968b5c5dfcda3f669d7ea68df85ec03c3a18688aca3fceeda2fdd5afcd73522cb9ded007a73f13a7c8c56708f49381ba54e6775453c80fbbba0b864c95c77acb2edce5e902922cfbe20d3fd517003736f83273e6f194393ab06026c99fe2267be5ce34f30885e7e4a03d3611859ca79398d1903f375eb4ea6ca1149b14fe129857cd9c6192a28424e26f27440d284fd047eeed0c2f0f20fc4865a026634a1c77899adc082ce8e6271fc694c11fdd151330f464a34c4858a7fab8ebf4856d45cbdcf01441fb07bc874ad36d89b1b704309729e9ff67d3d110e5c1b48a9b1d5d6ec545e77c35be104e28d0bbae4a13477bdc99d798443982edaf7a6dc0a3f1ed0af72c2409729b6411b4d8e2f8b1a5f109fff192cbb28273df2572e83bd771148b1bb131d74b6183c6af6e8894a0a8180d33eb86f84e346e0d419e8b27cc2dd04374d73af9aa9b390aea0560d1444d16d7e7760367def35490eabfdb14fa5bc66f706176e26a66a2f441a4fdd5afc1c58087c9faa33d7c278342233b6ee6150f83919a048c8f03aff127bb318f5644aa4276be8f02441425d93e834a1c2ba88d4192e620242feb484d461bfac876152c42e737961bf1d24f7058e6c2d1a1fa2e1a96859ea29a9ebf35b03e7abb827e6c946741587feeb86acc1c3835079c2ebfbe6742969a9ec08f59b0b302a4107c1cfc7338bb8266577e5b1088b168bdfa5a08090f233b0e3f8e50a1f802974fe6ea98a44d3f2a6b7c5c71b74abd1c5502b46421bb111781889a62a7682d047fff734fcf92bb29d79213812f611b3df12ba69870b6471eb9f1188e9a4bac049f020420d4479222c0d8fa6a6fec285cf32aa4a999a6b186721d4dfededd98e88fac710367826c069d8f43164ed43fcf4c0c77b1ce856ed881ef010a0890f6197630069fe8d717e270b95c6713071c3b76f7134b4f1cb6c51d0e40b85c83936e4c6e0de73e2b80fb412a45f8f64239028c6bfc00e6405acc91c8baa0aff2873e030c34a4773b4386603a71dcd6bcfe21e701212f85dff3eeceb573eb1d8d45b14dd8110ea19b26123645f54ccb5860ee2095928cef3e6172c43102e8cd16a2c8cdf682214946af30f19355079a3155290cc33db585f6cac5dc77a363c160501ed8b08f3031c86fd22f6ff0dd04e1e51a47f0f0022a4b1ce50385c052ca4829b971f63f5367c2a3556c1b4c6a8520b313859eec721e1bca40162b1f020d8a0384e41355ba62cf948bee5b062a5678584734b8deba57d18b09ca4f073b746aa0b52f3f4dcf14ed8b885c711cfc4c08a868c5bbdba242c313e53702a9ae6b26eadad0f321cae16fb406e225a786de2358c5e35fb50471c9060abd6cebe6d94e2e6258c258165a120dc272d13256cb59d1a8d53598f97d063d767779e74f049eca16bfaf40843d58a32cca76843b0a73d6c03193967253475c91502a915fe27a49de2985ff55e5fe723384eccfb70876778dacdd027bef742cabd658796422447934b973b06439ef2dbf09abc6543eadb55ef80ab2bfbb60a2aabd0943c276a7c318d62e754951425fe5466dac993554e92f5d687f47c75acd588088139680a5549d75133b34fbca3392d5c62d9d7cece13ddfdfde9d1badd2ab7647dea008709a18c69b63be69ef366c278f5988342b65aac7e4ae1261e63c58ab4c1fd9c49af12493c046dbff169916efea18fe5252912a286e62a28637fc65b614eb7c4fc697e7024ab720373542bb32ea6f55f2dd6a2c8be80bb079f1c011b7eba7dd71130482deb7a96977590017d551dc8527fd8e4e57f535a321c128bf5f167b6f96c7777164c7c51331f7ce5657564e0275b7df5afe4616e1dc3ac8a0fdd6177c55c6bdb9361ae88ce68b34b4bc9354c8300e069c751c758c66ca06a0a3145fa8792f467e7a8e701153d39a96480c7ff1bee37f24d2a782d592ae4e5f10223bd411804e193e07d3715182f89e78def57227d9175652767ded639b8056bdc05d9a22fe7c2c1ce120e048a258e72c6c9f5cbca1fa644ba9c632c3382783c4322a653f06de7320a3ba9e25f2ee084efa30038383f43e251e9ef0001613b3a3424ba05f52361b6b7632ecbb51bf6ee004bec2f427c27c496e0ee9ba2196f7e3d8dba65716ce3b66beb6c7b64422c6e34d66e1bf09865fe52a4631b2f139471fb4a037f7678cd5cd57bf84dc62bf99a58a82e34a5827d2fcb4dbe1a1dd1e869015d99b03b7e5f96332b9d4436b710b600ae934642e4b9c6b1311e60ff178377017d9d4202c41a015182bd40977a665436a96a7d8138bd73ecdfbba95c963a5c1018ecf880094443a5a81213b56503b0e6e3df63142211dbe299726f1d85281718814da1bf2fbc8ec009f0ad092715c8c5e68597f0f5c604ec5f2d695b449dd084a65059df29abbf7f9d65e1a1e1757bba4c55dd59b9ba20513d6c1e7a843e2d22d76862e9b21ed70936140b82f03083fe07603654d5d68398c35fb8c619b27f91e2b1f92e50f478d9885c2b66c1c28f764deb6a2e4a6503969be438e68b6f87158b9bced6f7049eb4b5161dd889eb61ec14433793d46bd404e2f0210a5aea0556014f8fcec6373d4ec806ddcda9cc5cde28a95d4dc5dbe3802cd3f9001b8249756741c6f4d2f72a599cd0b9674c186b5abdbf92ad681d98d74677e459d6cc01c47bb6b8bc676810ada4c77504b69918cbe63a1e4402356b61075db248c298af7b6816345b7682ab0e5a1bf5f3a18eae73d2541e656c5f3b38d458f8799a4d2a9ab421044ff1f493fc8e6c9f09272b75f4588609facfedaf5986338c611b547b9966b310b4003f9115f7b2278d68ef15984e5858ac4ca55bb06497aca6d16e96e20e68ce929e22671c971567167da64e3402ec7f5ff4ce7de8db45928241743fa687a664b2458bbb3edbe022bbac89f00d6c315036735b34aaddec1b46f7ed898342c826926684721cd1343fe803d96fe5e1b1d1aed0a42a78028c24ac8683af23d777713d28fd18896150dcb712ad2f95f9a84692087e6074538dc98f3fcf7e7eff2be1ccec6e3f72eb9637a512da4a57ecfed63bf23392b3761f78a8a01812248cd0bc0ee9583cb5b0c9ddda110018e8b68b7a7bf761e5f96f04fb8244a4be926347d05b7f3660677059e067d445c12f96a8d24f32d5b43993cc43403e3d8b462c1e9b07183a2d3935fa64374c8af7adf0e6654eefb64705bc970eef81051a011483bea58c2ddcabf797f57caa960b7e61bc48042d48b52ea41c84b9d1ae6be353bfcc08d9d39de9ec4fe82640bf05b99da80b164d499bacd5f278b7df6c448dd65b06467afc326a47b6fe5c38ada5025bdfdbfd821e47273154a4d561631b95ccf247a39b2201426de189b0dc56c76c19df8ff33bcf75e8a9d8e044ac2207811fef49e8093cd7aae4b692196d6e6a229c4d64084670f267ec1bc4cab93d52ac10f10bb93cc254af488d0e89c41d3ce4485c3fbb4eef3c564ffafcd0f4aba64a2f66841c1ad5e0eb91cfc1f85f836af90ca732bdf2e6535e7f070da712a57d9bc29cf3c2b9100841914e9f630aa6f65d7c714b106dc95156c079915234a7415cb6f0f136fcbc061eca71f6264f2164948f5432a1482e1ae738d4e265a984e4029ed53c87417f1ee2ec45c40dee94238ec1a3a7b3ed9c9773dc32ca8dd1932ea9030c8bb3fd54c11cc96020db9143abb9199366c8cb72c03638891820d596e9782a898b5220992253f7c83b3b95816ad07996eca5a99fdac27d92ff27c7e629f90d10b8c3d714a9ca9fd41a179127017c3cce943f36b06e45ece11d8224de35f71d7fa16d0f2a899a7ffa74905d6bc1904d1ec6e3bc875d2d59e32bd0e57beca6efc6fcb1dd67453501b0aae6bb0e1f32feb2b12f3ab05833e00e713d17b1ee60c4a50b5e05f945ca0e08384c36c5edfc2af61c9f35e7f40c1bbded103fc31a0eb2f799780427306e97abdbaf1e3ea0019ba75924c88bb48b777a3cdfc617af6ab814f5637c34d1bc9160b38f2dec585c1304e0fc4bc011f71c734f4e556596818d5e80f868367095f365eeac0cebcb587dbb72d4c2d853155284e2b95e30e03fe08b1b50ea0ab208a88ad0e86c480e8e3b9b4a2674cef37ef1c548e1b9306f509b37e5672aa7a7a75adf4c6163b7b49d1f41e267627808fba745cb9a314036ec98418579d336134ad3eaee63cccb12d389e011a0a676ef8fb325723ae6e89b0417e3885b3a2c4ea5eb5681edb0126ecfabcddea4a827da02c52a54ab58dffcfb8e2dcb0638f68237f2805d865b96d412b66a241363c9305bd3a94cedf0e8b7c93520e4c695298e0d597db053c5dcd76e358000a0b197a4d8721b640871058f053d77de52217652cd7108775b51423f3076e1cd413655604113890fdfd859f979577c40b59ea17d8d05af0f9e1901d6663202fb629f8a5e519e96d1d124b3634e327526698908aedce92dc593adacb2097bc2054d6d6d4809c0e92c0b89c530ec61ddbbf14f2e749c373626baeb7a13967dbf1cf87581ae6755f05b1925668be3a23acd0125bc3b4953c5627141e5789bfa47eae46d9f8c3823fd3cdec1ca28ca45004e53b8c55b4c587bf562bc1c6e790fa01ce7236930e99fac12377ea960830d94091d7b3c99972cc1928eb4cbaf8fd42e036efd2a751a0be71894fdf4068a0e2a3ed0c6803e46b9123d01892cd6ec2bf051892d440ec3878829d143b3db7272f19dfb5eb786293e73e2aadd773d679682436bcdcaeb5cc5f51f0a6f9cf6365c6b424034f221bf87355954257aef9d4112397dfc01aa12cd20c9ca2224c2116d94216601d34c9c006bcfd02d2c2bec456a693e53a7ef00df3ab6501b2a55582dc0b9ce486fd4da9ef6c43e83b77e6ec44f0615c5f520846f4f1774837b50bcf762aaa96aed628eef48c6839f7a29ece42743768315c962123a1d9fba31e235c92cf80b2f2988835ee831f99122c84a3478584e8591c3d806d5e78d7a680675914ab0378305f55231d9710dd6e271e6f2ecdf0af6abad9cf5174982acb0d4251ff68724e46bee70fd36f2e14e2aa184d94608f77497642b141d22a6a55303d0e4c88f084fdbb21b9403d5f6a51fc2c4864e63d79f123e791a329a69a96717e1468174f10ab815b448010f9dd7b619fbddd2a5cef6d890275287cdbbd0fc74b8cc288b8b09811efbcc809d4facbb33e1eb6435ccb1cc5962232c9b6f258794b94ac30407ab0c132dc95a9e77d6bc116420e08143e5e58bd73eb1c11576f09676ee89a4c180a97de61e5093e6b75424cb00f1c0ef4cecbea82a1d3688f1c850effc5564139ce05a2d25e06458ca3273fd9533996f35f2444dc098a905c15b1f62f18fa3dcc86e2fde24ca4787ea0cad16b14917eda980208890759427234c5757ce403f0accf5550560bda832db23e5d526cb36100489c0b7201623c99eac5fa60b838410db0ff0966787d4385ffaaf6213343203b078510e0a64beb848ec509c75fcc7797ce4e2ebb812aee2e2bd06ada40a01bf1adfc675d6e53ba46f027567c3d789d9c4952fe558b507a202385b84c0bb7dc455fa27029d5595bd3ad29d8c1534d706edf67ec044a6eff0dff7a3861ee9154683a5082483a557f072bf4b74e9c10893e818954c238a8a5a4370586c21171afd94d82316ef444f5cb6513ce7ca92c2916123811a1f2ec6ea65c360306257e8ed0fc9df9a2e1d91458f5a1c2738e22aba43a620194f9854330bc16bc698c14cf2df6e763b56cf2233137a526df63d32c19c24d357631289196aa7746e1f96e27d5f2b52f3bf808cc53d7b4e3520062f7273ee778cf359d199b7433658409101df8a724c4c321c21ae0ee86a683ae717005561af2ad3dcb248f6bdab2276a5f3e294e1f9ebc105dd7d84465571cec7b6178ed6cd84be8a0b54d3f4a7b8d386e86d2c4816408145222eca8d77c9912759c4f5e53042ba395fc39b6ffc9359283793959b8944fe79093b3e80179c23fed78e865a382463eedcc1b1dfc97fa43079b5d52f37ddef1a1a61399220e4ecf614008546e19759ad125c3e864fc60d265a10ccc187a1a7391043cc2f7a5a3d3eebe7c04db83da5336e182f47aab50350e722ed7321cda2a7118952fb628d4140e4446b87933a5817a96eb4e03f14ef96b8602fb5b6fcb36c88ad0ddb4ecebe89f14fbb2a50eb69f6de7bde64235a16b838c640c1b05ff885993e7609eb28a1ac8e54d8d948ae7a662a36cc99cbf21609792fe66f03ccb5daecb758bbbeb21d8981a8f1c68f41d1389c0f2727f35043e1086280543377c878d88bea2ae93665141587a711f4ff391d946028134ee566aac1beda94242fa1d4a654b83753fb6fb6e9a4152e5fee3bde2e8783ecf8918f5de7351566980f117f351189080042301a21bb4ea7bc437be2ce125a45882f6886fd996e3235c881ec7ae252130bad9c202815f722e60dc735d2b2bff72cbd9fbe627410313a4c06bcd2c728a54a247364cb806f9098d0b9f71ed406642b3e1ad8b76a7e4ab7d3426fcc8b92c8b9fded8ef0b0e6aa83941d867b41d50afd945e6a44406546ef7fe019b01d54af77c7640e8c796c01a4c027995ab5df03ca60d3f074de8d92b3a1d831394e8e85a41e2e1bac65342060002267214c67fb4c9f413a4c663c56eb9d75ac5d00c3ed4dfad56fcfc4ce76bcf378b48873b024c49b61a157f849c90d53d345a33673a8000b74fb577681b96ed97459964875d850de7a74ac4ee26e6a9aa7341d2b3e0af5ef73b91fa6a30457da3dbadd0666f72f5d281233edd9080c49e882a7d454dac54be71960db74cf95b4dc2977100116db8e310b3dbc883622189c53c291b0bfa9fc30fd9ebe34fb9bea43e8bf0b5e1d561e4ad0060448ac923e13626cebd8279b3f1e815f760353e5b0645bdbe4db819504d85106c0559ff028056b0e30be23091f33f2f2f3641bc0d55b0ac59684f05340c269dce5947c966d40c3422bbe669e2683839a9ba383a3f6f74895981c1a857a20b1c0e3a95394f7648c3be4327558031266dfd96612533d3d55078653fc8a35fb7b4a181ebaacb094679b4d9096af0ba4413c6cb37473e94ba541d4416a344bc551280aceb7bb899c2ce6aba30bb74bd2fef06e7dfcd0dfc138457a566001d92931a65c6535c620824fa3dbab52ff7b7db896a5e0481329fe567fcea54ebe38b8fb1482035ddbcef5f0695bf6ca29764c11794d7909b222ad55d32cb48f30d7d929c091d6ee5e118f39542f4c53efd6d2064cc4dcff442f9e2f2edcec3935f88fb6f107984c3f4d6b8317892fa7ced57f628c124a9bb1822f5009cf5e9d7b694df5db5c1a5bc9a39ad25cb468fa5719aa58be85a00ea69ebff23373cc4f204e804916ef78d3e4445a3fad5facb92fbfbf1d344171ef08ac9a789b0092116b63be173ff94db4e49297ac8f1edba2ea36c20081bb0b18f8c903815b97d50d15427b1caebdeaf4922686763a9a6ecb582aeef82c7a709a077392123cb8b4d17138a77913081cfb093ff4853d72a0efd5821175424afbd2cad69e7c40821642a1bef8290ea4e4be2b1018a99db206743506fe4d3a4c24b62fbc502813817ec267b221144a9be9084b077ae9113062bed4fd1c96b17f117d04b5e9939aff88f2c76ec828b152dda751a89e30bc1aa79939670b2c2f839955b8dfa30d0f6fdc58bc29988049a3e3c578afe2846502cfdbd9f2faed60165a6356a192842de52e145920e7f822d95638ccc2241740c4cf6cd57bdf12d131993e62031e54a41a912d2778118b6af558e5deced74b7f3cb1337bd9ab01f766a52b27ab75158a834f8afd6b9b0c4040d4474ab84f44302885917d1fde62ee3c5ed3e0056fee2ecb241e99a64e1719ce33ab0d4fbc197451393675d8d15fda6bb96112eee66138b0ba969b3a7b15c9aabc5c73eff54015f9576ba0904df137fffc552f4c7f9334d8d50eb4545aff2a0b13dd985b8df175063fd90b1d9dc275257bc83c228d76cf65f1d0c5345636407085d594079251a6891addc911e4299aeb763f13b052220d61be48a5778ce0fa95eb7714b5d4ad9beb44288723b1d92dea2bb13bad65f09726c002fc57b36c08b33e72fccc95694c5d3dd5b601effea82b49ff25af4b6ba6c3696b5c234f42470132b70f043471d3304f03f71d97c7287a987931489b965702fe88048fbda4da1c06db4a093e78f67a545166df2eb9856b278d08a4884aed604bce612ad0115ccd8ee5d5f6d060767f7dde967806c4331cb91e6f1e6e5fcd62e4eeea5a0bb90732396f22ed73e244537c849608a4d89665c3b708bc3bd28728b855a0a691d7ae45f021312abb45a9b8e7f12e5f298da1b0ad9ee2c7460ac5d767121566d41b9e2c1a915ebff8df12f86d8c1cb46e1a894941e376ae6e16605db6cebd6fea00918b9c2db720ad93359db7a98c213676bef24f8b1f27eeb30eff281ec103cdb21224a8efd81c0a5b4e681548f2c4a64a964c429f60868efc86155b32df02dc98a28aa801c1a8eed98f55f93676ed36a7d1354c81ba0a0513a59ee58e57f5e676b9acce50ebab0e2684e7f0c3d25af03355174ab424cd235e351929a6d3f5f07d22df6639379683a67b25ed79abf0068991a545","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"bd21db18b0420f54909ce855f4db2687"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
