<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1f9d162feb4e634644f71cb54bf2fc8af490ec111350162c8c8b4221ae078a4cd7e106aaccd09bb697b2d81914b5bbafce0d7df4a3cf1232627d2ca1de15e3e3d9f55494cb774899d5a7d58cb907144c6908fa6e76a78b0ed40aeb3b81c88a69ad59806f31a4ff02632b9a21c3f46b8f5509c45415780a80563601d789ae510f7dd9c7586131fd02a173a6b35db624f554fdd0e0fe0a2e9f878cbb9d3210d05019e9d15eb2ee743ad6d95bc3008115c27d075d507226ffc25d48c6fe324331750232c4a7ec823441dc0dd0872a39cde577144341f6ab57bcb1150431999f9827ee472c202230c210d1ff7770e742364a177989c357251fdafafd499bd32989ea704543ff59e1a8a007df2efd2382973497b23f7882d78cd4eb9b9743f89b5970f5ef7eb0c69220ab54c101afa77c301a188be526754afde6e7cd81966dafbc9d55f0090f8ea8ba3632e2f40a9d9c0c0c7aab516419e6bbccc5ece3b08d1bbe87e2802ee8e9e1ed7d9c30b4de5a5dad3ff3220774ec0a5979bbf0c14d435c1ad6d41617c119e92215f7d04de3f3fa59de1d79bc9f4ab8d29adb6f2bd76624ba635ddbe296297c27559afcaa71f772116f9d0fa6b773dbefd2501228715115e73fe335f8f01474105cb4e4dbfa593f967769d3c0613edb73145efcc3a3c4af8b69d6fb63349ce1ac4d07da9f969364132f0c98181ca7951bf45ae76f15dd5cb41d01141cba0a2af5fbabb7b6bf937dfec2f76d2d09b179ee1e0c52d55cb2a767e01b61b7d4b5dd330a8e6bb63587e6998ba27e3e0a7a9c4fd2397972050ffc9a3fc6e4d5ad8dfd55cb4119771989cb854e4cc696d6272317394f6ff836aa6f56f47e5189e3da244e72cd15b4489a19ae247abf0084f0171fe19f6948f68dd730e0e5b6753def83159f5e54ba1743e3ac0da48b45b2b46081a4ec07f69b85951a060088c40120b66892d491e011c1815397e2369d9078b31f3b223860885c0ec7c32ac356cb54869aab86af617ed3090402cedd2296766ca3bc2db11cbf3337d5e8b2612eadc7e016250c69c96f5d26f37c7e2fa916c4e689ced4d57a360f08f23a646860d92b2aeca4d8b62b4f156cc3cf25ece9d2ae115cf584269af473afbbdbca99a1feb62d2aa6aaf28c3a71eba9b6184be3f200f05265e1ed97bf5bb353a87d60f5f3647663e8ef2731f56e9c9829f2564ad423474895f1329a35af1f10423c3c7cf0a34eafc7aa1812a1262934bd23263ab8710ac09d03faefc961a560d1b9647bafa2e4372b0abff27c749673e6dfd3049f135ca088f37f986a46af9a1ef8363cc4a3f51282d16c8971ebf40ca575afbec8fbead86b71ec2c0ad281b08fed61aac25c91b9bbb85032e9b6bba10efe0ebc50db43fd83e736da3749e8927c44e855ca5efb4996d699a3ca8a7c9aad584e0cae9dd8288e5fa57a22f89218ab92e7b736adbfd1cb3719941cd1a0f3af3fd716ada3b30920230faa553258cf8600f7d8a7c95330c4b3affd56fa1973d0efae7899b6f3dd51b5f3bf843cd5619a4bd40ff1e0856209b37d3131c1c11ae58bf9b91e6960cce5f0366c8d4edea8977372900ad5d2e7404ac1b4a243822b5607e117e215e56f4ef063dd908e426e62a14486936cd997a07ff244bfffb93e11c3a2104459292433ef30f77a176702a5a2d8f35f8b22bc16f031bb7f40b144279fb9292a9f2e0d8733bce0a420a9c7bc511969ba91f1c6c692c8b34f6efbf537382be8fad10a8c256d5cd395d3fd5eab9bd1a52fde96849509f49fe929069fb0db599e4f540dcabcacf09489416fe91fd8dea14efb5e87d1bdd9f6d5854860758f4175bf2274d964cf49b1b70b98b5712047e73a5140916ee9889bdde037a5db240308bc3a7ec638d1bd2310eb7a249fe8db0e77efc3024cbdf2fef99593989a5497225ae1fae14de043f536d8d12a99f84328af5b685603dceaf3c663aeb192b0084905673fad16331f41f793bbdaa9a33d88a64641d78a7e97b1329ef295e710891a30015315673bd3b87695bd6782d3cb6ec106271926a3fc10f5651cf2ec9d94eeed31c6c902b94d70e46bcab7d02e8d9049eafac1428d5a480671177d05f5d47eb6798da3700d0d07e8e86dac5fe9266f1249bb2eef713771d8bce85790dd80e0740967d0a4d2e2e7e8b415b49a8bb0b778a79b82f2c5f52ff0d2adf20af7ed5d75ddeebb6feb0d8526ff4e59f8dfb9cb9e1254f58143ef82536cbf4761c9cda963430db913ca3a6707ed1eabe2779d635b7634363d0fe3c6ba9acae5561b6a543b6639d5c17f62cde41ac18366f3a4322651d301d36bf27f6fad81852017d331936db70b33578e1c6afca911645c5b67d4c681f5b2ced3056fffbd816cebe8909e048c4c68236964499744024f13486eb59b5a7b420df9ee0a37b8c37a9ebf627843cbf8f67bbae8dd848f4623950e4fc55268477d429b4acc78067953a8390f071163ebb0392439b629da71f181e8b518e733f16445567a0bcda6eb197347d8771f150ed9c7d2bc6222c425357961d03ed1058ca1b0a8a7df17c05ec08e6aa0124fe3e54dd25d19d7a15a33e017b43c677e4a2661cfb96fe41f134201ad83eeaad7d6bebacd671dc6d788e5b51e2bfbac878149ab1fbb3dfab2ace1c78a74ed9995688eeced9c7ccdb754ac3a4c8f93b4a736950e567712d7a236201bb8f70f18bba656ccb0cd1cfac6e0fb9f249efdb0759d6be4a1bc0c42063b3093d1e224fffc2ece4009a4ef1bda27237185e96be7ef204d8efa6f879d18774c82345d18dc01aba272d383a71f98a0c887f6531aa5900b2883e423f0db93a981d80915c19108f46de1af20277c2bfa9725c197fe4ab3a5ed0f22e446c667fd016fd78860eba9c6d96e27fcb05f36b3f43fa4f45d9801ca40e9f85fcba9e8699df7ce3b843d439c6153bb15ff997958ae9ecab4383edefaeb12b2c5fb4507d21d303137b74f7198e505e1f4cb62754763581a5392199ae1a11f53ccef52420234e8a21dde9ede30776128cdd570656e69b33e29f01a6ab8834caa52c0a1869b3fcad6bfb978d0f36abd151d669a0bbd2c70ebefd86af256f7018c9b68d9643474ab56690bd48ccb34b00ae42db44beea5cf292f40a0ece5a006850cf073f300a68bdfa72ffda8758e34148aae4b69a73c0bbed6b94e469cd8f95e91fbe9d16e480567e35c14b996230cf8ebe2b91d66dbbaf505db0f16c73263c63e5ca8f163778975be87ea84f9533742b2b2b07f3167d42223fd5f04342809b9a607d6c0d9b100d13ef3ce80b7cc067984ada5915519780411ea34d611b85cbdea033cd92f89bc37c190b6d40eb5b0a0aa8b3ee9c5547c7ed4dfdcfb0f55c81758f79734d67e8c70bf6cecd2a41a0e20fb65e26c169f8c6a67bfe09f4a47fa796ad7557d00532012abb73c63bbfc3f436db2adc8b332ae7a5b1eedd59ed078a780a666e2c2589daeaf18ae645e1e6e9351d5d950ef14d06d107a2f4d6a9282b73b1d9abebd583742ff194134612ab0b3c390bb7f8726c5ad80cfb2873ce58f60d84bff93df70f931843d2bf5ffc0c517d459a33390692c7f979e34f99b2b5dca6698ababc84010cdf2ba0373f71384a59dd503f827a51f8852f48bc107922c8022a26c437a71d35d21e62dad1517b2749fd42d0c19a382e4aa82e04370c31892776f43da8c79c6497e6624e9b1c080dd399ff0375173b9d8641197cb3cf03edd3161d72feb7274d7b8f06cf60e0b34fda2fba22565f4fab03d87552880cddb3102e09a6c964ba5c47668d9b9fe769adff7b46bb4b4673093a732f5449d13fff0da2f17bd13c667eeec149079249d4c6549e518a8a9510ef59385b1072b0360a05e6c0696b936686b99c8e922c776fbf6760c160d532dc869ac4351ff812f5761f651656cb8eb55de437e824b999b8de5b42213c272a7ba7d55abc21caa340e4121c9303d3cc0578a3dddbee4996f542801019c91ee71c4f52a233e20f16c57478af0d632cffdc65046d2f1fe6e34e71a8ccafa1e49737a5f81b30b1edd412e731faadc75bc9c0954f35ab7eec50fd940ce088f0ac9cae684aa36852681ffacb6f5d6942a8ef50b41c7e40f8569b2dfa776ecc0e4b8680d4c220cbb723206fd59e1b59226fa617bbdadf7290cb2c6110b842fa497e3f54cd55f4afe53127f1e4aac25de34f6ddc5e8185508829bd7d42f16cfa2103296df51ee585c00805a5b4115316ebfc2119c10a2788267e7b3ccb965d1ec18a4c31fe2d45b05b2723541d4f8da1909d15bc5e346cc8fcb30bef1b4fe0120d83a8888e018c89fb243d0efbde402235affcaced64ca1171c36a1a1d7ea5d21b43d724332d85f5dd20f46b4bd0f292744ccba12805730f7d4dc3dc9490c783a4b0a29a67af0ba2192e8ed02085fa3a6adc7a2453ff79aa52c8286d18f4dd876928381f9863e13fc2135a2d70e2bb483a66bd29c369f866d4723ae3820512b548f15dd06bb627ca1656c4370b2a8ecf19f3b472d165a246a0fb098e0d93a7326185dac97c025a4d73f916c36974f88d3fa4086c881c21a77184fb10b14a15497172396192f5b7001a79135df4bd6d8ea4a72a16d20080c04f22c4a01337a38b8c9a6ca4ff9fc2a87e5fb0b17aac8eb0369b24ee4601e8dd9704ac91dcc67b8f77d581f70105715b3b8d2f4ad468ac72501aba376b4c5743df8504846cac8349f5ac0d1dc4ff8750dcc460438092380fab6dccc2dba864845dd5e5df4751faae8522a3fc6189bb5dae86259c8c563c1d51d7d65143f0d667e5bbb9836478cd6252f6018197af85c2195d84120e23796743b7a783892645c2b0bea254fab7a8e27516ba9a4894d8c85a10221bf5e9dec2375109087169c7b8837b4dd073c0c3c58c79ab58a636aed192c97e49591326912567626ac2fd1e233d343cd2446d43eb6e865602edc05f4627a8b9386193c1ed0e05cd2a17f368b65fb2c14e71e6c9105c1d4bbcd3857b5df2375bf3eae49eab4809444f80eb39f922d2b1dcd329f7f017f097c8fe39731fcf61751b32ff959dc1be8398119d9f43ae9da9d657e64a2f2004086852532bb3e1e7c98c774725a751560415807b3f400ae1d63c10300331b0e3d48cf72c8210a39c850914d9fe31ff5b306d8dd45e4aedd9ae14d0b0e09c4644beaa13dc05905df4829212fac2daea31147d94acd73a6218cba281c40eb6d38d9245b9c0ae7b8d0650991133b617b5476b6f54bb4b0acab8c02f0084fbbbf177462fc8a31d7517cb1e118140cd0ce4495c64ff6645e5029a21ffce8935b595833a16b99cfc43436d1ebac31ebcb65fa0b2d61e16afe9434e97ef7f00e5a557ce362a08156773d169c0a03ba375339c4b42b1de777e1ef440f2d7cbc7cb950754b3655c840a65f33cb3d4a8b23d8b569ed5d7650027526061dcf7d8972776e4c5c86fc6fbf3341949f13e917a41bcbf32ba6d907407474206fe14966218d9d6ca5a70850f20a67084b04a599e9b698aac9ea8082428c5e4eff33383dcf1d1103c48eb27936640fef8a7a1cc322ba8830be2b71a5c48cb2942de341a75174f7c38eac58d9a8e3cf0585b9e79f04437fe8aeeb2735dddb48fbc47544628ce4282e9a6bcc3d2601cab29e96d76883fc1e5b8ac7d19fa655595cb6ea65359a3161c99b1138664697ca74f2de9e16bb4c0edbb4c36b7889eef8383fd97e2a5810100e3fbabf2509a1da70260daa30e0c259a221e6d36390c2470acdfb3814010fe36808419087b6df19b7458358cf574904db92baf095378204c703aa6dfca8b2a9c4842a90e21403e4edfdfea4d80b027b9b304336af487a7a707b2eef9d0208f494d6fe8fdd6a8c8461df912f739842307553c8db154f6b1436ea4445d1d2d3e15c3f2c1864ae2b0a6cd7347ae37bcd3ed0d68890db605302effeef77236c67b3ca7e8c426a71cd9dada4bc1c2b6e8bcd36a39de8e2bd4804ad09e71f91b03c1f7262281ec060258a30bf58aee4d0062a9b09e939ec47f8d07366e5e3cd022f816b74bb27c0de756d832ffc44e6c30a1892239dc7f02c434ce0562711aca075a7e9a11c6963effba0b2b8d51dcacc4f87a231c587ddaa461b65878820c04c5fdfd1b6ffd0994c1fa050c9d8fb612da8e0fbe26423bf8268f14ed4a0cc6fa52520c864d1963f1954c245193fbd485d2b41373f96a7521f12b5a1b5061608c522d3378004fcf00cba0477097e877e715e18fa1bdaa4af97449b62bfb40000fe47a69a09320c0062026b9c5610aa2180a05ca31a14070355547475ee38d169f99c57c05f3a54c8189c9af9a2b67205b99fe98162538a7338d55cc63ae6b0684d58b8595cae67bfdbad894e45372e6228fbf4c11a50328a5327b19058a1745451c9f3af7e073bfd19910df9d6e7e86d3e9bd3bedb87a4b27e29d1a69e805996ebf0e6cec356b7e1cf8fa50b1917f3177dd9966b684d44bbe3434dffb41321dc9eb823eb64cc237fa4de3e64d765b203407588d1f4c0c168c8ceb75d443684517a3384ec266d33ce8d1b1ac48985276dd5b8cac890a9db2e3e3d546b21d39fcb62270268833dc56c63df4d8fff3e1d18ff8860c3b9b662e34a56d4df72f6636ffebab537f01102bb2f31b7c2e623371eacfe9659954a51841411c32301dbda3a661921102a04b19d91d0d1bc338ff649f221d699f5f9d3cb0b596f4ee1c6d894dd19cf24d7ea007089126ef007d806ed97d1a0bceee57767be6b76783e40cceb5326495306c5cd90295d4c17705f587e77e2ee07146f28be1d696b7619842a9f47266e7d164991758fc1f1e7483fc844048dc828224cb6af8175f9a59a92bb14e4b9c58e39efb3445e1abbe0c88a13d0206f3a9ba38feb181f15859bb25a5c01c46f53decb5717507d31db8081e251c3a4a6300c4c1e33a134c2313a5966e42f56f6b77abcbf8ecea35aba20eb77baddf1c9d23cdff3e15ed2f517cad589ef0f77c1910dadfbe3a75eeae43d6a4adaa5bdb498140bd7168893826e4423770223aa6c56d4b339834ad5c567634e10df440375d4897460b12d3245d93d3ff8fc60bc446e9f7761b087507f0bd92c3db7d231f1176712c6137dcecb74d88a7a04268c0a7a48b6016a8dd15c81bc7b4e8dce1c402d5de0cc937f508f120ff60fd127e08491eae3a33c3b30fc012cc65d07eb4c52b5080247abe3e40629fdc41411238ca58cc04476e0a44d1c8e431b92a4f097cfa6a846f9161347cebd3e642ebcc881bdba9f8b0d9af3e0fd926b076817019df9c18fa00ea7e6c25f08e5e1b4a4f3b5e92dfb39c06cc03eaad93844649a6c3df99ad171eef161d5bcdb9d344d80e44ac85a6e9cd09b04f50122d452b64e99b8ee6f1440a45fd12f1a3261891fa68057fe528521cf63192719fff5a08610644d5a6cfe54a645b08275e37550388b9caf716036778b124df85926efb9123e7edd1ed0176ce6c56df5db4ebd907778c3ea66427ab953caf3118da75dd2714402cb02d0fc813cb82fe0c742d9b995c39a7227d2d270c0a4af7300b370ec53b0762c5e4b37d7d9fdd78c7cc91d69f57e4778d6ca29d6cc6e3b401b0f355eabdbdc8e3aaa78bf944edc85d97cdd661a1b344b47af9f3c52048f30ab2b6749b08fcc2dbad2ac25499741d58c6d799bf0aaf29e66b9d0aeba75efd3766b5308ca4c28bb44dc6b04704425f6a29ae241a427c869f40b851c32b896f06230552e0f0b0ab421933ab4d64e131a31ddd976c529cbd2df8da00e93d56929674baddadb827ab69be0227a6ff4a1e0c3654e0eae8be5ddaf755548aec2517ad1f6586aa0bfd49d2a9173b7ee53a29583fb447f25eba1272d43ca45dfaf2d2f6a01f0a43a9d83749c994d62a2989290fb739cb158e3411358628c20d0f3c3eb1ee41752d0e1364ae84d43bd48e9388fd7ed3b81638073e2d4689bdae0b4b7b700028e91505919e37600d09414077c6387a7233c36d6249a454602ca3212ecbe080bb9e3a1b865c0b928a68e122f347b52f174993aa0af050b2ddc0042a4a4e695bd84f90b00ed04b49aa43d2a1c0ce25cbb832c4a516b0c55fcb55b8309fff09d6df6f2096197d37d688cd1491b2bd9f22ca6a14bfb137adca67a914979e1c1925bd9568bca21051d086453be9e325e1e44289ee7ca07aedf48d45270e4a565748dd80190375d1beb0efb9c3a3601b7e7dbea79ce1c08aeac4813f1d2afb01c39ea1c88776e3223b5b7d580f6485b38896f0077845efa66d486214afa67b4afb85e749b1eb099e1da11f907db86f8b9ba7717701d3998ed8ee4be83156d344d0217b899e1341b92f609bd691d09fdbfda208b6158c9021bfb9944840c83710954598c3cfc6387cb14463ada987bf21d1f6eefc3a38626bcd92a8f1f02e218164cf7ac4c53a75305afab67e6c544f7e2db9c156cb5820b31db408bbaff31591a57e2b8b20837ba695f951706470426642f7661a39ad491896824741a6190dd1cede63fe1ffd1892c15abbbd6091aca636fa2127ae30627c50e99fa6a060eab692c5a6f28c8e5596cfba92ebbef470041251ada0c6fc828289fb4cb2e8ef2f500ef21a15b526c17432eeb1fbc6dcb24561d8304ab5b9b8624400e17ed0f618127103d18760dfb382fd6e1da77106760ce7b807ac6b7a292bc15fb227d9537d9336936bcd4794015eb4c69618d67f9eb8ed70b409c4ecda39e2c18106d6e63614a18ab992502418773f7a8adf1eea580b629140512a1cf4398b7a63f7f115d6077ad2fa6be5bb243547ac609862153aa9e96280aa601dc4238f36a2b68a9ac674093e71813ced4403fa0bd92a34f8432445d2e26e2564f68789343f19437b67ae65ae9291efbab75414026b630778cb9eb41e4b71057e7811a5770c8dfa4a532be9639f2774fe342529ac3b7166a126a56aa37a8b645475da4ae69de51dd5976d74dad2729a7341e4aafb47f7f500664c1e26bcb3f8d00e3a6ff8f8b7249df8ef9603959b0208781d544d96997295c556d640a1db143b79178584847c1b5c2815c0203bfc44de0d91b6b9658ff3e5469caea44881e02971c689ec26afcb945feeba8100e06f3ac782d01ff7bcafa2ff0697b55a0cbebb987dc430f19d250ea955c12320b1c5b9751b48b1672ce9ed141a008094a305e60ba4ae417649c00958c9f83a810d61758718b6db8e6c68214bcc3469e8b23cf1b6a36986753f5895d9433d7fe9a0e14a6d4e17c680a2ecb75677602aed0cdf83e2a6d174bae443eba19ff0350ac74c67e99933b4e82c51098bc16cc7f19ed1d766319d868c994cd7f664a41ed1b5b180f3673aba73141722365fc16fb4327bcf999e29b1a651f474b6617e8fc98651b76c6d38d03bf7aaeec08459a4ea49fe75ee1b4290de6e6fcd34297a68719c1de236bf3f8c5898bfc3820db71e5defce1b669c6d4eb88f85f9d3a9b6e9e085ba8eed4c2629af979046bc980bf71c907c8166c3b3fba45dd773bfec450ddf89faa08bd61b9986877c6042de5eb2cc2a1108aebb56677f6590f7a723e18ac8056585678d4ff8ce9b84ec4b670b705afa6f7becf38803c12a4cf923ba51a819a852a95b0dc2ffaf16790775e9ed99d80aa342a42e64e3bcfc98f84eda8da5641046298853147c4a3a312396e7c8ef235356c53cfb62388b7a65f96a6ad831339ff6b9a70bbc56c67de01bced7399d81804a46aab225c488b550b97f4dd6f4a01639824a20f54384240316b9dcbe6d18e85e92fbfe656a5ca353f2cacb4e4d9cafa54a471c5462640645fd5bb7102c9b49ae449b984008c429083ab68789ad276acf5622d1e95a8a18ddbc565b2bddbd4b6d713807e5b89ea7ec044d0eb1ba135068ec166704564a3d226e794142fc0e93d52dcfa550b233eaf88097f533d2f931d5ba13b7eeb1d3454ef6fc41b56435cca378ab159767413583ef387d1e9fe6d0822681331696907b33850c416c29e096a4ff68644e026e639873256b667c05acb487654be7c25196451459fc93cfb90cec19af66f99277803f2598221a6633873124f1c1e34a2f6853b963a398f826e81e6ba7fcc53af7f9edb689bb3e2cf72f4b8907dbcc4926195d188b7d909db69f97ce7231d011f6fa6142b425a0dc9e17be68bbc251742cd845247ebefedf527981696c8f816305e3fd6195c1e70f43bb75d90c1a645eeeb5b9b414d09f810a731502f5e8fe09e78e309d0b4901ae26ec2e0f459c36f6663479b2bab36d3b5484e17e01c3ccd076440266dd9c5c2d52ab79cef8d2069937f38a03ba5d34c8df3135273c8c947ca197ad816f0bafd8108043c9ea0d9a90625e508e089b94d5099e09301031b98871fe738cb1c6a6caca46615788495ea543be969449317cc58b6c544df2fe8d890062684bd952ab75a3b95fa879948594527c9442107c6e070d85678c4af1c9d0352951960d4fccf6ef2f4280bc71523e3fb03ba0d875e030d6e4a4edefc7d7cd24cafb31ef7ca4975b1388b558c3fe3684414afd9d65f6e3b11bcd72bacb8eb3479bf0292a6ffd1bfd5aedf7a2cc7aa491d9ae569072cd023ac0ba0bc59f1d958981a6ff562f98165a5a0920ff1f0fcac66c09a5b8f943025a985878baaf1f775a704b493deb3bd4f3a0ada8bf0146a990529c8b5a052b81efafc6119968acfd3cb3862875f43b40e8da9a7fbd29cfeee03dca7d4ac879a0242f8f32a631f5d70c456c027ea304bca38a3e4fb2872eff6cfcd74ec9ff2bed0689a2e24b8bced433eca1b6485769f5d51d27c0cdadacb0594946de214a41c94b17908f7326eec65dca55555d89eafd05c6ebb48ae4021ed722bd2a4c6751c2949610137738d45f2132daa0b7753b8b2ea2ceeac9eac6d83603f56e12596ca297e933295e95d1f3e7108d4ba21296cd2e7b8bd2fa44e05b922a42af197fcdc4dee25d763ea8e7a3bb643a1f019c5bc426597183c171345acdc2c6eb1ad467387ce942078d7556ca8a8de79670ed33f64c24cc869727a15004535034c68f56d700754652c1fd6b9024916e7ea23b8c854deba3c4f445450a19d6a020162cdde6ba9261f3f5f13c62700adcd1a9d6033ac6aee64915e5eb687f1369570d2251961998fa7ef99c7d9015f6edd8ef4989827dfb8aa1a559fa4df8082f393249ae60110a80f4fb7f13b0afc33ff4cc08fc9e49de58239bd3fa6197f99d1d364140b2c8b10155a1e33acabf7b5e0e5b1c9cd0100d9140d9293d22f928d3b831193c38ada4b4a49537c899137db14307e5e99d68cacd34df2b2db6bf8d3e49b534e79ec22e3ec2fe9eb02652a386b72f0cefd1741169a39213ea51497b83637b910ed766ba1a1f388629d1cf5f59967927d861913d56e1ba10284da51e66d1a1ee46e6c9e3444eb7019fd49ba3b7e86185a9b9612369b87523f31b846dbcfab67ef76779ecf71f732ca76d9ecdad8902c21b5392ddbb6730bb7910e84f890d378c832ccc785cc68ac7f0ce02bcdc3c6bba7a431f564d4770aecc6f53f55ccb96d6fba71330aa9c9f51e29117835b54a5017ba0d65ed078b5b4a3c74b1525624d4ddea69bd04a8a8b73b19478cd7aa8258b8073fba28ab0c355779d0b5a8b433eb1629028e298334d1ecadd8c3cb0eca2cb735b78a21e4d47233a89c77fa101ebf6fba4f7342752a44f974196a0ad5c166d810cb1839eb3b3fb0bda244713f50ad376dbb0eecc7add528ee8f702bd6ba47d7c354ad52243ae41238a6eef4c029d3d6a48d1433495e32f85811ce3de5089543d0516a61c5f9c60207b547ddd8b09285104fb9cbbcd2c6f4a30a80cb9a499d124eed789890a6045a4f5280f4afdd935c365e0e6109cf2406c45227f7920626ee59be986845d5df0ff7dd330d7630b120d2fe9a5e656df5dcb3f20ae933d3636965510d3b802fbe50262cfb37fe8bc75ffb9bb334e9ac7ee542fe6f1d3e72e26a5fe43cef93f083ca8073c4297701501ba1798ba56610370c8621e2e36a42d3944955317c5f3c9833f3ba5446a4c362956e085bec9b82aa357f13d2a0b6b8fce54f9006f0c217a649a6b960dbd70e021606268bbb44cdc00cc5223f1fa452521534a1620c78eaac701606227c2d3d674873517302fdd44a177c9cb84f43f58cc59b4d4bfa8cccd5209caf6850203e269a103ad7c548004dc7dfa9cd5f056ecac7c65c0c3b2a6f6c019bec301709d91b8e04985eef8f8095159d2a5bbac6aeceed78e4455b9b12b2305fbb9fb2ed611028063d598eced448a46135b9938aa10f3f9c856cd636c18aa1491d5b021ba156bbcb70a0d2887cc6d61420933baf7e003f8b051530826102d7e853fbda1360762c0b4d68891d87354b276ce97433492cb6e9755dd4089732bdc947132fd2d6e94b8e71f52178a38ba3db14f86b189a203a65236eb1833c911f9a9d39116aa49f53f8e96bc333b35b5ed83672c5461aff6668d1d1210b5e8c8242dbe83528aa33e6c220659350fde6cea9921cd404219ab7317947d40e75ff52e8aecbed8924ba80bdfdbe5336b690c1721d231e88161fd73d61c80142571866bab6a2410ce55120689c6760f941586821c9884de1efca6f54c4753c0fac158dde02a8bf180fa2794a9dc28387c335ac3ec893b81e96baf1533e482c39e9f843689e125bfe46da339818c64a6beee93b742eeb79c1d76192e50bc3350cd9218305ea480eeef2d4b60a8ffcc6f3f7d6c1302039daaf0ca7dd27f8ba74f3832b03f6ec4c51fa0d04aca2d40fc52c017f1ab6b8009696c60383ba21005b0080af74758bf19d028ddf42af7d4becf64ab261cd85d045178aeba5a7d75f253b543c9ca7dc686584542c4ac0776ab791d08722e8c6143872bc435e541208a9e8ecfc6154cf06d437ab7de5e28f07ee8aecb05f9d4d5d00a1c010052328669a6e66a1ab23b221a888d0b39be4e5cfeb260c1ab11603ed7cbb4265f2776daabedd85e7c701d3c81de61ee33bcc2554bdabc80888ce334750a1659990989fa119647df588c4467b7d80162bb5c86cbf9939fa5fa576d9d1720be3b77ab5058f1f129d35de788004c66210891b2a14e906280f67719ede5f4b98b133705f49358c00fae70533a32a4a7c2a4d384416fece632eef8885ea77ec2b4b7fc5ae82b87cc0ab09e8c94aa4b06c91efd68316089de86234316eb1200476521234a50a1be6eb9179bf375bfb7be26efe234d359b529ea969d4b63a549f414f24a4dbb0138dbe7a75f1b40e6cb80a5fc2c85fd10c3c51af1dabd31d1760809eb342f27f094289f5d89f950bc876e4334f49e2ca1acdd6647f1af0aeb020f117ed619475e54517efda5583412b0c331cb7700c6e8429eeeea1d534b02c6241cabfb9786714c91cfe65d45206000a404cfa46d22122134d543dcbb02f151899af6d1e37064a27ca08b5ee42ba3b5d7378aa7b123697860ba44ad07e7ee53b6620588c893d26a32cca4bb0f9feee1828a4c0d74b8a334d3ac2830435b9eee2068829aa7c64c07e3a12efc42aad9a53ae1111f3ed6b2ca7b799eae52f87ea1add9bbd4eb3668fba3a289d57ae8937535b7765d7f2a3da350c855fa3eee6a92e6e30eb8e425364cc2c7199a77ca50ec197a1dccf434eabf9f9a247e38169233c6cc6f49ae3abe75d8baa3f130ea136c258bc049618762b07fe777d53805830d174cbbfe880d4d94584823ba2ccec71814bf621fab842d7ba1f6928782413a8f139b01d7296b65ac95298d87b6a20497ca0118512a60d61b81cebaa76f19afe7ee4579295f2b91c560d8737a897cefd270dfad2bf9e77a3e6b29254821f039ef956fe104c0c851c18f3504f053f1a150a36c2271f8ae0cbd20b1386670c3c0da0805","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"59fd7e13954e764d60337826b4be4489"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
