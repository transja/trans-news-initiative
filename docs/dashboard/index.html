<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a576cac8d8a9e5fe3424e17175cf2293c2d6b5ea537f0d4afc1daac8a38234a7d70c80b4d710841212e954cf448bf8f78f40a1604dcb195f7ac149c84e1d98aa8c6ff4a9207eae100cc25298a7edbb4de091b83ce1d7d065224d5d856aae236a4e40923aa17293f7943144d22ccc9e4c98e872045b3798b5ba31963407a3cda944d76ada9e36ddf2564e75a59faf9b55a9a718bb1a35d705d659973ee298c39a26037ccada23d30f4989d0556bb346a00233fbca4421e9cc3a3bf8c1a49147a6f465cd435aedc764388fb9b9be28e875fae1b87a7de53890be982c5281fc1a0eefbf8922a19c518fa6d564ff8f17782c8b1a5dc44ecdfe01e6370776d13f328bca064e48bfe28b64e9359871aadda71be34fbe338d370793954af0eefc8b6a4d813746b225c5a250ffeeb2aa59c59998996b147fee6bc39aafd1e074c6715cb48706f35d0e5922182f7d1ae3cae7222836dffdeeeb6f8cd2f19f73620220766b0f57923cd724c314733c1ff1d37abf23c676bbd67f1d664c5f77c3cf80faef9017d31cd8540eada18758301f6522725935bedd621f8b31ca9eca523278fdd10215d95488b5909de6676b32db0ade208469b8012fb3fa232d43203c0766f398169600e4929162c49dc719d2651a0496243cd86b3213f5b7497313c8c871e1ec486cf29e074627ab9f621b7d59835b0d695fa8558051e796a40a8077dfb7bce39f300a0d943f6f81944a4644f115b6e1edbfaaa428b5f4953a974b89babf376d8bd872fbd35dbc72de1fac33f070fc6d71edbfdb74bb0b737924300e1a1871f7001ffe953374d6b4a238e1497f6c712d63e57754dd149fef90dcb6d0653916e8daf030fa3dedad52cce6a7f9ac2d7349b2515bc036ca002a9e5038023323e0036f2ab91de39d975e7490f7ecbb291e3655049abfe6679d891b5f55ea2b435fd3fc197963d8440357704cf8152e318193f6a3d3be7b9c4d510dd11dd02a35cfc17572a60725d1e356da289b7502318cb8e36139de5d61a7f5c3a76b753fe175e2e356d3044dd53ec7096a5986daa988196518a69744d025194cde6cd5976cc1f6062935dbdd4f80f2cdf30327242bb68378dd08dc5b716b5f8b2ed772508697c12be6f582c1b304fb15affac1a160054c2b8fc2651d7d3ce78dd1a8d5ddaadec7ac8a37138a48911cb9f3ebe325573653487ed852605ead7e678d56c2bad7212bbc63500fb4af8b600b83b03af42d0054cd875f6d0672fcd5e0d92bf65be91d597940a65b15fa883fa59215f762367150364296d854d78acfc37b5b2a94f14a701f63478794dc3156003189df73cc61f7235ac16c372e7a9e40d4be1d99f4cd0f6aaa81bd5a4f25534cc5361cf111d71639137fb18be7fbeffca7f2f007c2e87491a11d997beee20c1fb5148a17ae7c7b241be6953dabac727e4bd377eb259a9bd078017a2aae79c4974108870a19d21eef6709a8c1fc75007a564a54dd3d4e62919c6cc1223b37964d807e4e924cd20479df1a2fad2fb4738a5f1680a9dac3bfecc77c114f90853ff2ae3df4d77ce7372bb82f3d22b7a52f1a79ab6df96fedccc0cc87a45d0b1bb4f9c2b1790f666cb53a79aceef66a2e2e62dca18247ea782bcbe6ddeab759f7460c146fafb90509f6581168e4f3f54fad294e548b8f1351139a43c7ffda85b868af0e401a90e33c6accf188cac28e48204acca43b9a87a28f0990c2b2043bd3315cf1bb51f2963b3a4ec4a9171d4944c44d9b485faa69b69eef5a14d4aa9fc57126daab676fef094bfdd7b9ffb689ca17ebb1ca4da4f52573e9cf45cfafdfcc6c2685d422319fdd88797ad5f44e23153022a922d6c33751813fe09ecbe734d217a05b4713ea5e7cc5ffbaf7205fc5a6069e9a57f633dc1649674ab9fcfb2e38cdaf59694ad9afbb3845c7f5ce780151f7ddd41ccd7b90d81270ead863639cb2a6e70282dfc265ca7b88bb838baab55b25d9c3ba0e18f50c05fc299683b4906b23d3751d8671a644b70bb6fc9f08a61287e97918a28cf885071ae88f673fd1e9bc567a5bced7010325e170efd2c98d9475b5586fe51d34fd65e85ef0dd9c4ef880793ce3ac1850a399d1ac0d3b608b94249484cd0d6761a91c9c0c9ced278e5c53c452397a21591397bd0e31ed38d32428185cac320f2f97df7c5bda5bc35ff906e0bafa6cc62a7ccba8fcfa96cc632302dd8d8b6a7c2bbe42cfb7d2035a46a47dbcfa06d1c1a6533b9daf4e2c380235ba0907fb1a999c433054352fbe7a6ab30452046bb21a1214d1aa5823b3dd20afd578c73785925ab137cc8fed7403494df106df44d67729b631aa39d5e3139a6631d89ece8e03298a53162abbfc34f410c94d69bc51341961a6071c05c6998369350c4a5f833fb5c0ebe542d9d5e697a17d8c2294cfcc2d6a3d691bc21986093c9ce7747e0d8f3e2369f1ff07e244a8d37f62ed18b73c9633038af4d5245bede6d81e0849c022db3b13b5d924e319bbae498b3fd96b23a2fadba10072d66e8f80fc10a0232a4cfee6202cac8e20d29b8eb973ba533fb77142351ba90688fb0e6bcfacb1253f1de71254a646badf77bfeb5bea3d2fca8ada4b4c39d4d89d8c287511842a4ad42a3dbc0b29f1f9d9a2c0f086a7d592dafa67332d4a5bf2356e0e3af1a8a0401e61abc70c710ef4627d04b5250b644395f1cce24ab7928f5fde43f05113444b0ffc329f3f97ea155e18dd8b56ad29d1390a7cf6ed4cdcb1fad33124f6a849436913ac729ce142888ebfff674fdd334abbbd972dceaa484464221f9d1fa352a001f704d3301a0f58e59d23cb25c42de5ddd1a765acdd04c58f88abfdd7a08aa623485612d71cc87bd087bdeeceb262bd770bddde6c8dfbdd447755d8a02c703940c1bf9727b201d73d673185148d273f2ff425bfdedfd311f285e72280159557071f1230938b9919594aff399710cc282a7dd2d240ebdddba29d930428b2f0881ccf336535ecf0e996d1a1def54465a0a2399c43e7c99f43f4d2e5b2d6e2726b5411bf560ec743abb33e50d784adc7fdb8407ecf4f9c0a1d6509d8349aba1fe5edc2aa5d11f6e347f1fe06dab34c11b7c49b789a34e21f37f55a085c761f19750329a73414570fb9f5062ffc7904e0e01090237adfb9ed03f3fa061b421a210dca1cd930eda72c01bc7194e4edf7918ec858bf133102812ca3c07585ec7e32747bb4cf5b974ff0de9abbd10858481b491adc0b8f7384ccd5889974837fbea249b341829f9a6e668b19563ac3e11565c25a404c715556786233606c07fd8b01958e726f8802541d771f104713615ea4c3c4b55f5b173bf7eb676f033c3183e6f894a13094e0e25911634178794e814d29df0400d32c452ae7c2725ef0908134c33b3db278a72fb1cfe5d88770d000f74c3ed8d6d4d3e411e8dcd50634dc7690f700bb6cbdfbc0f5561423e2425ecf274b5d627ee5e9ab37156b1f1c6b8abf1b26f0e2683479d18de43f50ededb0c5e52441566bf58f8f3bb36abd45896be90e261f1876b407590de80e1675dcc1e7210f034c193162606e9a67f8792f63b863ca3c876004d7654227239e35449c9e4b9acf6b12328e629029347a7119bdf826b0a5af14007265c0729ed47040bf0b8a64cc402c30411556c54dfdc1cc04860ff77a8f762dfb60eedce342bafae947fc61acf5eb825b30fae239fa5b0865ea116580f6e92dfd1757eb972b3ecfd9df202a42cc9143cf2bd7a99b279bad7173dac8b9f2c6c5cd8ce3fef2e59a7d37646d3886fd10cc783f13fa12664a560c8109e32d1bdcdab297920fbdc6ce3c102a14a76808fee970a2540e05f249e9efbd629ea51ac2ea7feddc761416f95f52d6df3e96775b237206e51f11048deec07582a74180bceba465ad987dcbdefb26ffde5c0d693c80c594ecb1771fd751345138fc26501c87b61e05df3dc88ca7670d721f07b0708325de5ac1db109230199025b0364fc29ade1e3d8d51ce6d0761540cc101579750d609a749be05194e878315ffa39af56f687faf6a22071a0e3ef206121cceb06861dcb9803b5d8a6d3adea4a36c469dbb43b92a1fb7cf1659df79cffd08094c8e2feab858facd1c6a3fc9b6f2e8942afeea13129d9a8cd01db1efefee9de9a4d0f788f369bd5a23a9738ba91feb3506584d291ad6abcfbc4065bd0e1b301023eeeb359b8df6360cddba21fab92e8730bb7b6726578fd65140b5c5c3d55cee0151b36ff43fc63933b8b41c7a6b3be4b47a1c5b5688f1c9c0b73299a18c02204e9fe11da89171f986df1012508f2fe8db19ce19e5d702cdf2eb5ce3cd04b2b04f6a38f3c97d0a4cb6ffee8fdf2f55201b8e6de9b959367eff74f8d5ae012911208e910c89c1f81ee799d70d046e009e71e8cd2a26da18ea6373b0bf99b412e3071739d89bbdcfe8e86ec5b9f0094bb7fd2d4af7097c7df0415dc90c5e3939dcb952c077a0d71db64216b3c288e9c5c85ba3f4fb6eee260ee6ad117b02a229e040adf048e6d73d0829e5056f1abdd6929d672692b92b774de12b5bed5acd5387a4efda204046d800c4beb94576addfa8b94882f8b198ec1a71d2c317fc80f4cc3ba54ab5bc9907455245d87d8b77e20013dd509fb302c94ce45c07fb656908d32033daae8b8f5aa328741a4387c6f84a6621b3d15b5d65c51dd0fcbb3ce60b95648daf14aaf0bf6eb76b0596404d0d9eb62c3a61151244a5a415a4a74cede35c0c87e4e02c9b22517bb3a53c3c5bc663acf641ffa7a99ac8e428c41008318055018733846d1517127b99bc309b3e50f4ee2b576ceace5a40423e9119870db040a8274fc290ecbfdeb29572390d6fc52169db9a520c630af95c654e3b5919385dc9dbce1836b7845afb71c572ca026206c4d0ed64b59b767bb2ee9646b6bbc23d1e12cdf23834fab330369fc02679b6966909b9e7d8037b81abf6704690ff7f6e3f6a936292f6e9c71401b359f3ff077a544ffc2d3e5ec4839bedd31ddf095bfe7b6ed4daeb15c69f490147db036e209257780253f9d92f679696703aa3dc1b6bde66ab52adaa8480b31bcc00ab624e563015ca4f39e44c67a7ab9f9ff9287ebb89ceca956052b7707b93e3aaa4eb10a09aec626d70e727670dadf9c8768cecf6b15fdf0ec373e5fa6eecd7383a190664269893cf345648c9231bf1efda7a860ac55834b4932e428c1e68cdd14c7cc477dbfcd9a6e95304d8104e84b1395d7e3e8ea30fc89152a6381918b15b6b64b8ec687fa0fbae59ccf26cfc727e7bc575b023847d5cfab736cc1959bf184209cce0df139e32f3cadf029a0bfb783a3176a78bfb06614d36ed5a45e44112e657e951a9db880a299bff7a66b85900429d1ea7fe7c02a34f2229099bb597b72152d201c2655b76dbfa64ba61fb282b5f6692c2232288f06b63e4029a38c8ed51ba1b61f1d0fed5b4bc44f206b854fcab085afde51bdc35452047beef5c17876a00a63bbd75e3f5f1455c7f8249c86a41f382e3082b3937fdb0a48fca529c55ed60d0a166deee1431a71bca32343e175c47c06fa62119486353bfa57569f92bba8540255b0f72778f2b41d7b371b243f1eba4daa14b94ad0dd78572fab3318cfdf1c43b14a63c17534409fc3518ef6f06c43b43d9983bfec19906a252e64a484686f42e00787a21455bfd1ffac76b661a2a2030ee8679db8288f8f0531fd7e5fe0b898f94f0e9d659c64e851b47e35f42682772299e6c61aedc7d8657f3217d784de623b44cc588c6cd6ce363b4fc83c334eaceb49ddd74a863b048de9d25ed93f4cacc2edaffc2dfdd33e4901516bfc5de6ff783623b0bc5d9cc12b9bf03c582ce8e6b0d92b764a6457290bb5a9cf8467a37bf27ead7912698bb217b56287765cd96244c2d207bea1505baefff92c8c175f1a2137504f443ef3e96702501218b16eb3fcfb4feeb03d1f957acdec738f236c1bda991aece02a5cd6840f4dd8527c2853114ff5e4af929557be732e039d4f978334851ac8d6e80ac4c219c66898982b061df6cb50a67aa3153cad2a8dfa722246e4fd3fbe403889bd17ed82cc9650470dc1dfcfd091394422bd36808d90f5cae33a158fdf10cbcaeb218c49bd11e6e9f596a19343fc4d66d2f02e3b2c3750dad30a4aedf9942b23d59db3e476eca2d151110daf0f16f2edc1446214f71880eaf6008a2b4468fce482545e3c96a17bd8f1fe7a01c27e4b9903e30fdb4a5606324d560a1b26fadbdc39270c3abd8a0e082152b42e92966b2f364776e972b32afbf03ea18941fd82fca2a415171fed46e2eebc55c3dac1a5c9b0e1f7a716d159b3993c1e3b92690d65d93bc96eee0023a62646175357398c8610a905ce0a322a1640e5d124ca3ca69d4395d8104ec855e5c5ff6ec8742a9310af68540a5c290e70b1b31ff7d0d3849200ab8b40eaee7acc408cae361df5162457278a599b990fa48bfff03713210466e024f7842b54f43b37710aacc1a1272b636e075605915bf737e26c439597c2a1d9c8cb58782795412a7029c64784b9dea4c02f1c346f8d6c00b4f50ca8118bbabc5e302277afd872326890124308411bef814fe23978d53859a0a0febd0c3f400f645ac5c9e9b55ecf86a76c20a7fde54e9b8476b3135af1e7466ee408ef0ef717d2f12ceda78464237a1d2805818f5e8acc50cc7ddad2b7d77a0509c4786681eddc8cb0ed0fdb7181ca0eca092e7552495dce1b1522fc39aff1f0a48010f8a041d63940af5bd4513a88f8f6a00893daed25a38650cfa0b53ee8ab9cb243a2e455d001b981f75beb976bdf8e948aad2eebe113ddc45570360e2a58196edcf7d99b291130a7b4d42e4396ed9146dbf3c0fc17de1aeb8322b1c5afc30455dc35ad5200537e60eaf45bf94388050d96488d5b7430138c6f82e68b562d61c91ccc18fcc02af034c46964de0fa197bc1bf8f9ef4c9f4b12f6bd81f196cfe7b463d356af8a37bbe146269825a5760137dfac252baaf84c103affb77389d20aab4ccf31da5e4f69f15156ac0fc11cf786e690b22bd7ba369980ff550890b9ebbebf968d3c795834ce3fb87c69e2af7d0aedfce5c66b2eca4a4d2c1106f8b467fe9ab6a46e13f7610cb66632263f493352da464b541ed51152109fd9cfacf2bdc540f283c30cb365a007ee96dc50de52fe99d4463be756f23182d46a9ca28fa430fc72024cb053f22ced4a39f33d54916e6693c29b57551186e0ee26d5c6e150de94ed7e88e09e7a15e99253c33ffbb0332a4dfb6ebc96b5e085553f1de8d0d75b074102a1c4d56e0cd2f65934ffbb7b0acd8da9a5a41c32fbb7d9c7d28d76fab38f2a25e382b9a9bebc5a72ea4a69703bc8f75e81e18c138a65aa962928f65cd8436d1f4b0172709c1bc83fbe97c5093de155b5b7085526232562c98afa1853cae4f1c884420635d21a145bb3bee6d787f8d0a85fb49940a1db15387d466015e89d581708ef059af10446c83198cf0bab1d0c9b5c5cc63f6fca4988e8a14b598f8f0ed4194debf97265fa5ebb6f84d126de2b7521476fb27ef400c1bf72e1fe8730cdda6e6df6cfb8ecbaf15968769c574d9942469cadcce7428eaee045fbb7c32b1500b46266d10f29d3d04df35eec9c8e0f28e68cb13b1e53eaa94d5095b420fb07ce4bb34811f82618a275f6e6e3dc854e1e701bbf0f309789df151a0eab69479fab8fadf83c39fed8930bd473625cb17ee0f155b519c5c7380cefe8a9d6478093256e6308e63fa179b6381419e1a09ee750faabd9108c7c5c2026d044b26574fcffe4c4f60b84c9dcc03f701f5e19d1fea0db56cdb850ce112987c52054d76a428ba9fa3b3c009bd24424c0c38be25cbd042855120e7859196471f06d4b74d5369d5c379d970f21124879ac97674fc0f99d51332d319274cdce461a642f102aec837cfb2de9658f49fc43bbd22d18712241c0db380b08fdb4e212754358c7ff44455390f4a5de8acfb2ba69c67e868542e17e5730f444c962b3e6ab28525492c3c1f56c15df6da4b77aec85a216cb0a4d303ec84b3fbc06d81663e8cae39a11f34f37d2749cdc5178bfb109633d4615366a852781764e6332af3c5d0b195a668be647d57da8155677ae66247106c2b8b28f00a0c035658b928b661f3837df7d7fecdc23ff9cc56de6981c64b62366d3872b29dcedac53acfec90814aad13b2eef83c712fa8189b34034186adf253abe6fedb6461eb74c79621592590ed80d853f4af7bd8c80aa8da322efed7ee2f0335e77f92b9e538c030af4605fd90d0651d269ce05c6d497b3389773e5b62668ee11b240c2a9a71e09d4f34bb6847b7617139090d611238282217ff25dba79a7a0823c2c80b65c51ea7cd7fa1056f8377cfdaa16304f5b157b23d999a62c58866d7c8746a1b6e472226bb176d3d182213d9b122cceda7e35778b41c8bb3da6c6d3e620a8bdc94eba7dd7020f6da71cd5bbf72e131a9a64e33471c2a2380ea4ce4693839fb85f2fa137a4168c360c0b97a40003d11a58f3b95ced19bf864e419f4e1565f9b771f1c2fd302f3c7400b2a24a00d969b9fbe48b0c95696a46b2f132fde67009ec9a9b76e52dec4adde6d835c317a662657d4cbae827389bbe87b38996af793d6cf4fd7f08627c12597801bf7da0847def37bb0619b42edfa75876133498035cc5fba0d2f2579e270b1652497fb7f58f50629d61f5dad697fe47a62387976fc52245b8fdc4e4dfad8d23fc3f12b776bb30f372a1f2d295491053eb7f69591bfda882e5a817494868de6aca8beb24788bcbc2a561039e2ac5d50e502cbeb36ab4ea13aad11e924cbe58efdee3fec47080e02ac29984c72601e9f677ef9cbb23ba9a64b8237c6623954d37f2e96de900d0442e99203c6897a72d876dcf3eeca9df65eeacfe14b501160d9287448b0773c502ba0b141bc78cf6b11f90612f4b061e561583dffd7e6c3ddedf4e154e032185e49484bf21c8fa0412e2c3ac0f9e5a991a5a17e8dab9bc700cfbc7f071bc42e128f050d9f40a642798b7ad3c70fa6fb3bbe8f041ee27c69173cc20b879f0e4d7bc11019def2e8f87c24b993f062a43c7bb8bcf85c11910441d3ec1ef51692956ae9919528e823a4e1a098151916457a9e00d8ccbb86fe6248a4e8fa0c695968bef5c34319bd6a45a949e99bc4a132a921c759fc62179a25e360bb87948d51a88a90b09430349b672af4ee4d8ae054a48755d48ffa124237e0babdb84de8863cea6b54c20d3b2d265b89dcc0319fde9590a424fe278da92b3ca66db8c24d54cc7a19433c2396053b79338b53b2141763f9f264f563fe9839667600c5709668aaaee0b180249f6b1bb980cc9d39a2644d14b2f4274d4d68690f18397356d70fa64529705e7d670272446fa5efaa22049c9ef5166bd1b6822a27bccabe35498eb5b40cbdcf21ca9e316789bddbc69a605e7a16d081278d0c41fa7dec313f7bc10c19ccee4a26091a49b959db9ad3a1e0095b1857abd7ea0bd457993ff08d6ca1343b7678530d59086e675f7e8fd42881a3ebb8fb9226488f96469f34007ce592d15d41a62f79599e282e469e3ba177bae87adede0f22245a54dc372f408088cce48ac2d8c97696e5920985a94e7adf6d0ce3f4b883f8458be6e935842af4d50698c89b751a8b08191894b024307be49bda623bfe4b6ad575154b4e601662f3a6d93fcacc94fe2e46842f2e5fab962a32e731927c3d5e9d8764b3ea2f33dad02dbea92d1c7821eec312878832d78521a539f8f9953b0b6bf1257376196768526ecd4fa9db7b0519cb2e09c1c6dac81359c43267558a4d60d9bbe6b5f41607fab308ed8e8ac05a2386590e25229754bcfb48d2f47c09bb2f569e7fd18c0c969395a1f005ca6ebea7f6f5835f4662f6065163c70ad2a69098d3f1c7b03ea61bd0ca0f26eb0d5cc123a802c52c661201aca5d4e8215ddb574ef2186ec270b13adad1040c33f5c54ddcdaefd6f55baefd2d70b3b35a1337e61a16acc18e594e868a56b576dc0ddb41a726efd318247f106431c94958deff5096917659fbfbae168bdf812d4f9fc8cfcbe6497c02336f174d6c19b010500bdedf7582113f4faa32cb5994c89f595c4cf518cda3ad060183e123c2ec8e6fd898496fef9edb62ed324497de38c96a0b8f0658b649f6bf1d4c6c0758ab24c67037d0e7de103e85c626c0facb5d062a616922dc7664bff8b1acf9b6f7dd4cd8e10c11a96a39e56d3a0583c34e856e17e828f1f7cb0c5f0ca0695b16031dc2a1f5d868bc763fd72a7a2240fe9f635ef2a87f1dbc57aaede4e772c1a036379a19e94c267859de2d004a588edd8ce20cc1cd0d92c8af5f661df3dbc2922e2180c698678afb4af273c91f11cff55ff62542e46b46e56dc6ee2d8b37246604bcf6ccd963b5455c1c61db7d5f6542b0d09b19abaa306e693265b45cd148db8d421b4cacc710c69e8e59d57a5ab7abd7e7b0d057df6d0ab8c9c052eef0058fbb953d42f166cef534156a7b37d6d617e580ec058fb84be7ab754d28c7c526f95f856f7650808c047c9180a2313cd84b3ce4965f6cb3ed42529dee09b2ff4485ff62cc272f8c9b0a4a10343781c1c0816b9a0e6e39707a49e5637203724a128386fb5460c18a68722c6fa99e0c9cd015c4dad1e06462cf3d4af4bf629f56a5c45014fa04519234115a83e2cc53e64cd5db8fb80613d7d204e64a3e57a82eb9c961e69c2ff8c11a1f00087025094d4acca75a79563c2df014bf31ef13fd8421027638f1db8180a3ab8fcfc4f5d66db88a373d2004fd649676901e037d4c84545e66c13473bdb8348e5b0d94080d1789e8780c0668df6559ea0d2faeb13ab82165e44991b6a96349499fccd0dfc7c0b783ffdb57b34f19f2be3e644f0c3b4daf2cdb3530ba30e061d24b04c6f9d07249360a9efdb003fa3528ca94b12440831877747d0107cb3ba607885bb87b8cd6bf95683ac19a96593ecbba7620429d8eb0f9b4cae2c8c8536a66bfd2496351bccf5ea96f32e4a81ca50c1ed629b4ad1fdd90397deecc4b5b430c0e40ccf09f37e108beeaaef42cafdf4f513121764abd741a722009305489b9602c6a453db3ddbc1e3d3363407403054cd0244f734476cd1220a29ba1a6662fd10507051df411c8051214dc82d2ff00f8ac948a28bf68c41bbec8c095ceb4f5369824c165143a4d2d8ef51bd4e345221e5148b1ad550cd8af9156888c5d0139525067760d7b8c52d9f0ae6df031976fe4b7338ef38c07f7a0d02b4290c756452fae41fd44763a6de5c4229a6e73061921956cd9e1e87513a66332355331db5fb5518dd5e8bdb0d7ccb50c8b4a60444c3ef14f341efccb642b3cf827a20bfaf92b5e5e12fd42b0f3d4dff7871e35a82710c5d702a3f4eb04b92764c129cd4bc43ba8e41c9ee3b9689f687f0869ae3690311e536f0963954edce1c66b01cb20fe70e2c23b900953279d46f34ed16597070c6a8c182117c1fcc9d61b931ade722a84b5e859e2c4089c563fff44b0e78b40f249e62a0f17100a920518e302f8a7cf5a9f7c95172e1c8aa5544c31f718d89fb90d26ee4d5468e69ffe2c29279134324e88ad3f9b8f207ba9a175b709a298104891da8ab5de3fea3cf6ba54479d84289e4356b05db0fc847ea964e4156ce2f777f671269a6ac4221342c32ded61cc02f4e29078661fa6244c063502906da2ec52e320d05a2b564fa380f473af14d1794f98354ac12e40faf33243055ed27134e9321aef61211fd8d3a21da4f72f09205cb0de87aa891facf8a66ac0ed559212ad1b7a65a77b5b1d3101b323471f3b266d27dc0e3f09cd0b36017e2c3b8291d1240a75b1f56eb7c4726239401cfaf19c19599fae9431e495115c9ae2fa1159e8f0c8bd2e091d29a5f49a87bf598282bb2bd99fbfccd835f320d01668e546f1f7f870429e13c1473ac469d71420e0653248dda0c8cda9cd51f7890169ed0055df3c59aa6f7386e14b969bdc6330a42c3acc252401782eb03eb9286cf6230b510033ec9f37a9e4bdd6a52e4a159bbb16a10eed2f476d03e52b7c3970ed9e2405ae9e848826834c94001dcc6f63fe273ce71a243a347aab626c88ed7ae3bc6d793acab08406a93361d43e24c5e54148db6fc520252754a564782ee9a22ce8c0b75706bd6095fbab11f5bc1ad6dd600e2366a8a9b9cef874d2f91e03695b4a3e695a6867cd3b6d09bbc7cedd0e37ab8cd210a61b136d3cdfd8fc36e5216aaaad94a2f2bca1927e5ae71e4e3bac40011c8ac5427f9e724a1e2d1efc0b38523a348d0bb3dc99619807aa7790c29632955661ec6f4ee088e588916fd72d6a7466fb73229504a3da298b014fbcbaa8fcb9f50ca95b191288214edaaf1850ec308bbde6f57afad9016ec0f1020f0cfa0a26d62c54ea8a5ce783acc23220b1d5b3c72ba30ad3857c28706834dc7ce90798d2319667184d46898a7af58fcbe3e8fecedd5496a9e7a8d4b59f37325bc925e8fd9d0ecf01b11d3ec4e70db8237b2ca05fbc7145a88df58cc980b27e02c995bc51561e14ce38a1f844c00cf58b303ba6a2d65ed001c2ca1b42ffbcc84c954f2c9185c2a8d483aa22ea8f28ac29d20bd23006296f2f62a3b50424a812a8a92f3b80f29c40f7486e51a87d2470b43a7c119f6b23d64d48b7d93eb787ad6399ca0d0b193e0f50994210c7e8b40043efd6244b2477c53626be05ed132e0a787ba0647ce065837e028a61bc8fd32f45a021cae0388096477f7106ded51cd236f5a245f88211b472793b6a41c9160cc78a1721a8f00770b3cdf04fbef94832ca3ddfe6b0d644d0953b88aac4d81a9e5c51bfe6592529fbe034fa65ec52a9632ef55c612cc2e581aba35733399916524a1245bb0bc8c7c8047533615331518c2e88d2a338fa73200bcfc3691e34886ce7f6639aef14ffb0a637a11fb88833149ba31db7db7d2218f730b3478cb7f4b8284309f789447802bec58c85d3b3497ee417cd57a3df58a7b9fb633e0e48fb9b9321bdbca39b2a3be1c8ea1a1af7baac933516000d7a5c4cd8c66078a1e88e5215703447f1106f14bf06a8b2e1d7bb85057efcca2c1fea9d24020647801eed641053f5a6f6e113121d3946763c55a69ab116dca250b904502bf2f1e1f3304cbf3b628f522cfb71d14bd0c0cb79c1f5f0e823474e992fa1e540b68400e0d622d130d31b927335cb84641a350065332656f47fe24763125951380d5bc86e69c8c6c814ce0dec2a18c148eb8d26c3fcee999cd148fdc11a5911a6ea9cd7246a8e9728ad3ce7f4eb36db25c7b806ce8d397475817eac1cf461fc047b03949aa1c1e1af39cabef25908c66b7f45f40bd0e7a47e850805ab431880bbf80e9bfd78605200685434543340c0788e591559e332eca294c33d40a5f8809d33ef4ed5550cc1f3a329e5be2bb8fe9b8ed3e969d8105a6969620b2b82b254b9a91d6d425b7e5db8530f15a7a6dc40b9b01d6b9476fb889bdebcceb9771af21617ba3f3be85d6fbe1794ab6195b189c34d263a40db61163fe20a23799490958a9e4cf80194005cca916d75275881f99025944304a8ccfa16e97e23fc6935ca0241933d595cfc43cafe4a39dfe54563c4775bc4c9d3f3d5bb22ae199f01a80a8df02b3e90babdd9fdd896ed78b296bcddc9327c419a44c33617a3495c5a97426ac9666aa80441cee237cc57c745101c6ffeb1c633b167151fe1960b82778865cf0e09a138bb2c2d6f0413a0a576b5432cc733461d8ad63244e7b2d08a56ea14a0d50c21e606d6b2c8aba3781b7be389f2c2012757ab030c4d55e484ecd042544866a820d06564eca5527fa32feccb1c58e4f442ac2f60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d0714bf4f515e091144b95ab43b23bcf"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
